{"2016-01-03-improve-nested-conditionals.md":{"name":"2016-01-03-improve-nested-conditionals.md","sha":"43f619f3d2f30b86613bc0f234ad6df9026cf923","content":"---\nlayout: post\n\ntitle: 优化嵌套的条件语句\ntip-number: 03\ntip-username: AlbertoFuente \ntip-username-profile: https://github.com/AlbertoFuente\ntip-tldr: 我们怎样来提高和优化javascript里嵌套的`if`语句呢？\n\ncategories:\n    - zh_CN\n---\n\n\n我们怎样来提高和优化javascript里嵌套的`if`语句呢？\n\n```javascript\nif (color) {\n  if (color === 'black') {\n    printBlackBackground();\n  } else if (color === 'red') {\n    printRedBackground();\n  } else if (color === 'blue') {\n    printBlueBackground();\n  } else if (color === 'green') {\n    printGreenBackground();\n  } else {\n    printYellowBackground();\n  }\n}\n```\n\n\n一种方法来提高嵌套的`if`语句是用`switch`语句。虽然它不那么啰嗦而且排列整齐，但是并不建议使用它，因为这对于调试错误很困难。这告诉你[为什么](https://toddmotto.com/deprecating-the-switch-statement-for-object-literals).\n\n```javascript\nswitch(color) {\n  case 'black':\n    printBlackBackground();\n    break;\n  case 'red':\n    printRedBackground();\n    break;\n  case 'blue':\n    printBlueBackground();\n    break;\n  case 'green':\n    printGreenBackground();\n    break;\n  default:\n    printYellowBackground();\n}\n```\n\n\n但是如果在每个语句中都有很多条件检查时该怎么办呢？这种情况下，如果我们想要不罗嗦又整洁的话，我们可以用有条件的`switch`。如果我们传递`true`给`switch`语句，我们便可以在每个case中使用条件语句了。\n\n```javascript\nswitch(true) {\n  case (typeof color === 'string' && color === 'black'):\n    printBlackBackground();\n    break;\n  case (typeof color === 'string' && color === 'red'):\n    printRedBackground();\n    break;\n  case (typeof color === 'string' && color === 'blue'):\n    printBlueBackground();\n    break;\n  case (typeof color === 'string' && color === 'green'):\n    printGreenBackground();\n    break;\n  case (typeof color === 'string' && color === 'yellow'):\n    printYellowBackground();\n    break;\n}\n```\n\n\n但是我们应该时刻注意避免太多判断在一个条件里，尽量少的使用`switch`，考虑最有效率的方法：借助`object`。\n\n```javascript\nvar colorObj = {\n  'black': printBlackBackground,\n  'red': printRedBackground,\n  'blue': printBlueBackground,\n  'green': printGreenBackground,\n  'yellow': printYellowBackground\n};\n\n\nif (color in colorObj) {\n  colorObj[color]();\n}\n```\n\n\n这里有更多相关的[内容](http://www.nicoespeon.com/en/2015/01/oop-revisited-switch-in-js/).\n\n"},"2016-01-01-angularjs-digest-vs-apply.md":{"name":"2016-01-01-angularjs-digest-vs-apply.md","sha":"15f13b9d7389e38f811664b709f39b15f935a090","content":"---\nlayout: post\n\ntitle: AngularJs - $digest vs $apply\ntip-number: 01\ntip-username: loverajoel \ntip-username-profile: https://github.com/loverajoel\ntip-tldr: JavaScript modules and build steps are getting more numerous and complicated, but what about boilerplate in new frameworks?\n\ncategories:\n    - zh_CN\n---\n\nAngularJs最令人欣赏的特性之一就是双向数据绑定。AngularJs通过循环(`$digest`)检查model和view的变化实现此功能。想要理解框架底层的运行机制你需要理解这个概念。\n\n当一个事件被触发时，Angular触发每个watcher. 这是我们已知的`$digest`循环。有时你需要强制手动运行一个新的循环，而且因为这是最影响性能的一方面，你必须选择一个正确的选项。\n\n### `$apply`\n这个核心方法可以让你显式启动`digest`循环。这意味着所有的watcher将会被检测；整个应用启动`$digest loop`。在内部在会执行一个可选的方法之后，会调用`$rootScope.$digest();`.\n\n### `$digest`\n这种情况下`$digest`方法在当前作用域和它的子作用域启动`$digest`循环。你需要注意他的父作用域将不会被检测也不会被影响。\n\n### 推荐\n- 仅当浏览器DOM事件在AngularJS之外被触发时使用`$apply`或`$digest`。\n- 给`$apply`传递方法，它将包含错误处理机制而且允许整合在`digest`循环里的变化。\n\n```javascript\n$scope.$apply(() => {\n\t$scope.tip = 'Javascript Tip';\n});\n```\n\n- 如果你只需要更新当前的作用域或者它的子作用域的话，使用`$digest`，而且要防止在整个应用里运行新的`digest`循环。这在性能上的好处是显而易见的。\n- `$apply()`对机器来说是一个困难的处理过程，在绑定过多的时候可能会引发性能问题。\n- 如果你正使用`>AngularJS 1.2.X`版本，使用`$evalAsync`, 这个方法将在当前循环或下一个循环执行表达式，这能提高你的应用的性能。\n"},"2016-01-05-differences-between-undefined-and-null.md":{"name":"2016-01-05-differences-between-undefined-and-null.md","sha":"4d047f48b892190640ad6da0a49e7c6700fb2651","content":"---\nlayout: post\n\ntitle: undefined与null的区别\ntip-number: 05\ntip-username: loverajoel \ntip-username-profile: https://github.com/loverajoel\ntip-tldr: 理解`undefined`与`null`的区别。\n\ncategories:\n    - zh_CN\n---\n\n\n- `undefined`表示一个变量没有被声明，或者被声明了但没有被赋值\n- `null`是一个表示“没有值”的值\n- Javascript将未赋值的变量默认值设为`undefined`\n- Javascript从来不会将变量设为`null`。它是用来让程序员表明某个用`var`声明的变量时没有值的。\n- `undefined`不是一个有效的JSON，而`null`是\n- `undefined`的类型(typeof)是`undefined`\n- `null`的类型(typeof)是`object`. [为什么?](http://www.2ality.com/2013/10/typeof-null.html)\n- 它们都是基本类型\n- 他们都是[falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)\n  (`Boolean(undefined) // false`, `Boolean(null) // false`)\n- 你可以这样判断一个变量是否是[undefined](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined)\n\n  ```javascript\n  typeof variable === \"undefined\"\n```\n\n- 你可以这样判断一个变量是否是[null](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/null)\n\n  ```javascript\n  variable === null\n```\n\n- **双等号**比较时它们相等，但**三等号**比较时不相等\n\n  ```javascript\n  null == undefined // true\n\n  null === undefined // false\n```\n"},"2015-12-29-insert-item-inside-an-array.md":{"name":"2015-12-29-insert-item-inside-an-array.md","sha":"725afe26ef99b5918f5cfffd0239beaf04d3795a","content":"---\nlayout: post\n\ntitle: 向数组中插入元素\ntip-number: 00\ntip-username: loverajoel \ntip-username-profile: https://github.com/loverajoel\ntip-tldr: 向一个数组中插入元素是平时很常见的一件事情。你可以使用push在数组尾部插入元素,可以用unshift在数组头部插入元素,也可以用splice在数组中间插入元素。\n\n\ncategories:\n    - zh_CN\n---\n# 向一个数组中插入元素\n\n向一个数组中插入元素是平时很常见的一件事情。你可以使用push在数组尾部插入元素,可以用unshift在数组头部插入元素,也可以用splice在数组中间插入元素。\n\n但是这些已知的方法，并不意味着没有更加高效的方法。让我们接着往下看……\n\n## 向数组结尾添加元素\n\n向数组结尾添加元素用push()很简单，但下面有一个更高效的方法\n\n```javascript\nvar arr = [1,2,3,4,5];\nvar arr2 = [];\n\narr.push(6);\narr[arr.length] = 6;\narr2 = arr.concat([6]);\n```\n两种方法都是修改原始数组。不信？看看[jsperf](http://jsperf.com/push-item-inside-an-array)\n\n### 手机上的效率\n\n#### Android (v4.2.2)\n\n1. _arr.push(6);_ and _arr[arr.length] = 6;_ 性能相同 // 3 319 694 ops/sec\n3. _arr2 = arr.concat([6]);_ 比其他两个方法慢50.61%\n\n#### Chrome Mobile (v33.0.0)\n\n1. _arr[arr.length] = 6;_ // 6 125 975 ops/sec\n2. _arr.push(6);_ 慢66.74%\n3. _arr2 = arr.concat([6]);_ 慢87.63%\n\n#### Safari Mobile (v9)\n\n1. _arr[arr.length] = 6;_ // 7 452 898 ops/sec\n2. _arr.push(6);_ 慢40.19%\n3. _arr2 = arr.concat([6]);_ 慢49.78%\n\n```javascript\n最快的为\n\n1. arr[arr.length] = 6; // 平均 5 632 856 ops/sec\n2. arr.push(6); // 慢35.64%\n3. arr2 = arr.concat([6]); // 慢62.67%\n```\n\n### 桌面上的效率\n\n#### Chrome (v48.0.2564)\n\n1. _arr[arr.length] = 6;_ // 21 602 722 ops/sec\n2. _arr.push(6);_ 慢61.94%\n3. _arr2 = arr.concat([6]);_ 慢87.45%\n\n#### Firefox (v44)\n\n1. _arr.push(6);_ // 56 032 805 ops/sec\n2. _arr[arr.length] = 6;_ 慢0.52%\n3. _arr2 = arr.concat([6]);_ 慢87.36%\n\n#### IE (v11)\n\n1. _arr[arr.length] = 6;_ // 67 197 046 ops/sec\n2. _arr.push(6);_ 慢39.61%\n3. _arr2 = arr.concat([6]);_ 慢93.41%\n\n#### Opera (v35.0.2066.68)\n\n1. _arr[arr.length] = 6;_ // 30 775 071 ops/sec\n2. _arr.push(6);_ 慢71.60%\n3. _arr2 = arr.concat([6]);_ 慢83.70%\n\n#### Safari (v9.0.3)\n\n1. _arr.push(6);_ // 42 670 978 ops/sec\n2. _arr[arr.length] = 6;_ 慢0.80%\n3. _arr2 = arr.concat([6]);_ 慢76.07%\n\n```javascript\n最快的为\n\n1. arr[arr.length] = 6; // 平均42 345 449 ops/sec\n2. arr.push(6); // 慢34.66%\n3. arr2 = arr.concat([6]); // 慢85.79%\n```\n\n## 向数组的头部添加元素\n\n现在我们试着向数组的头部添加元素：\n\n```javascript\nvar arr = [1,2,3,4,5];\n\narr.unshift(0);\n\n[0].concat(arr);\n```\n这里有一些小区别，unshift操作的是原始数组，concat返回一个新数组，参考[jsperf](http://jsperf.com/unshift-item-inside-an-array)\n\n\n### 手机上的效率 :\n\n#### Android (v4.2.2)\n\n1. _[0].concat(arr);_ // 1 808 717 ops/sec\n2. _arr.unshift(0);_ 慢97.85%\n\n#### Chrome Mobile (v33.0.0)\n\n1. _[0].concat(arr);_ // 1 269 498 ops/sec\n2. _arr.unshift(0);_ 慢99.86%\n\n#### Safari Mobile (v9)\n\n1. _arr.unshift(0);_ // 3 250 184 ops/sec\n2. _[0].concat(arr);_ 慢33.67%\n\n```javascript\n最快的为\n\n1. [0].concat(arr); // 平均4 972 622 ops/sec\n2. arr.unshift(0); // 慢64.70%\n```\n\n### 桌面上的效率\n\n#### Chrome (v48.0.2564)\n\n1. _[0].concat(arr);_ // 2 656 685 ops/sec\n2. _arr.unshift(0);_ 慢96.77%\n\n#### Firefox (v44)\n\n1. _[0].concat(arr);_ // 8 039 759 ops/sec\n2. _arr.unshift(0);_ 慢99.72%\n\n#### IE (v11)\n\n1. _[0].concat(arr);_ // 3 604 226 ops/sec\n2. _arr.unshift(0);_ 慢98.31%\n\n#### Opera (v35.0.2066.68)\n\n1. _[0].concat(arr);_ // 4 102 128 ops/sec\n2. _arr.unshift(0);_ 慢97.44%\n\n#### Safari (v9.0.3)\n\n1. _arr.unshift(0);_ // 12 356 477 ops/sec\n2. _[0].concat(arr);_ 慢15.17%\n\n```javascript\n最快的为\n\n1. [0].concat(arr); // 平均6 032 573 ops/sec\n2. arr.unshift(0); // 慢78.65%\n```\n\n## 向数组中间添加元素\n\n使用splice可以简单的向数组中间添加元素，这也是最高效的方法。\n\n```javascript\nvar items = ['one', 'two', 'three', 'four'];\nitems.splice(items.length / 2, 0, 'hello');\n```\n\n\n我在许多浏览器和系统中进行了测试，结果都是相似的。希望这条小知识可以帮到你，也欢迎大家自行测试。\n"},"2016-01-04-sorting-strings-with-accented-characters.md":{"name":"2016-01-04-sorting-strings-with-accented-characters.md","sha":"80137ddecf150ea79f4baef4daefe6b20c12528c","content":"---\nlayout: post\n\ntitle: 排列含音节字母的字符串\ntip-number: 04\ntip-username: loverajoel \ntip-username-profile: https://github.com/loverajoel\ntip-tldr: Javascript有一个原生方法**sort**可以排列数组。一次简单的`array.sort()`将每一个数组元素视为字符串并按照字母表排列。但是当你试图整理一个非ASCII元素的数组时，你可能会得到一个奇怪的结果。\n\ncategories:\n    - zh_CN\n---\n\nJavascript有一个原生方法**[sort](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)**可以排列数组。一次简单的`array.sort()`将每一个数组元素视为字符串并按照字母表排列。你也可以提供[自定义排列方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)。\n\n```javascript\n['Shanghai', 'New York', 'Mumbai', 'Buenos Aires'].sort();\n// [\"Buenos Aires\", \"Mumbai\", \"New York\", \"Shanghai\"]\n```\n\n\n但是当你试图整理一个如`['é', 'a', 'ú', 'c']`这样的非ASCII元素的数组时，你可能会得到一个奇怪的结果`['c', 'e', 'á', 'ú']`。这是因为排序方法只在英文下有用。\n\n看一下下一个例子:\n\n```javascript\n// 西班牙语\n['único','árbol', 'cosas', 'fútbol'].sort();\n// [\"cosas\", \"fútbol\", \"árbol\", \"único\"] // bad order\n\n// 德语\n['Woche', 'wöchentlich', 'wäre', 'Wann'].sort();\n// [\"Wann\", \"Woche\", \"wäre\", \"wöchentlich\"] // bad order\n```\n\n\n幸运的是，有两种方法可以解决这个问题，由ECMAScript国际化API提供的[localeCompare](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare)和[Intl.Collator](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Collator)。\n\n> 两个方法都有自定义配置参数可以使其更好用。\n\n### 使用`localeCompare()`\n\n```javascript\n['único','árbol', 'cosas', 'fútbol'].sort(function (a, b) {\n  return a.localeCompare(b);\n});\n// [\"árbol\", \"cosas\", \"fútbol\", \"único\"]\n\n['Woche', 'wöchentlich', 'wäre', 'Wann'].sort(function (a, b) {\n  return a.localeCompare(b);\n});\n// [\"Wann\", \"wäre\", \"Woche\", \"wöchentlich\"]\n```\n\n\n### 使用`Intl.Collator()`\n\n```javascript\n['único','árbol', 'cosas', 'fútbol'].sort(Intl.Collator().compare);\n// [\"árbol\", \"cosas\", \"fútbol\", \"único\"]\n\n['Woche', 'wöchentlich', 'wäre', 'Wann'].sort(Intl.Collator().compare);\n// [\"Wann\", \"wäre\", \"Woche\", \"wöchentlich\"]\n```\n\n\n- 两个方法都可以自定义区域位置。\n- 根据[Firefox](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare#Performance)，当比较大数量的字符串时，使用`Intl.Collator`更快。\n\n所以当你处理一个由非英语组成的字符串数组时，记得使用此方法来避免排序出现意外。\n"},"2016-01-06-writing-a-single-method-for-arrays-and-a-single-element.md":{"name":"2016-01-06-writing-a-single-method-for-arrays-and-a-single-element.md","sha":"6d7725f72914286b60640ff7160afcdca74c9416","content":"---\nlayout: post\n\ntitle: 可以接受单参数与数组的方法\ntip-number: 06\ntip-username: mattfxyz\ntip-username-profile: https://twitter.com/mattfxyz\ntip-tldr: 写一个方法可以接受单个参数也可以接受一个数组，而不是分开写两个方法。这和jQuery的一些方法的工作原理很像(`css` 可以修改任何匹配到的选择器).\n\ncategories:\n    - zh_CN\n---\n\n写一个方法可以接受单个参数也可以接受一个数组，而不是分开写两个方法。这和jQuery的一些方法的工作原理很像(`css` 可以修改任何匹配到的选择器).\n\n你只要把任何东西连接到一个数组. `Array.concat`可以接受一个数组也可以接受单个参数。\n\n```javascript\nfunction printUpperCase(words) {\n  var elements = [].concat(words || []);\n  for (var i = 0; i < elements.length; i++) {\n    console.log(elements[i].toUpperCase());\n  }\n}\n```\n\n\n`printUpperCase`现在可以接受单个单词或多个单词的数组作为它的参数。同时也可以避免在不传递参数时抛出的`TypeError`错误的隐患。\n\n```javascript\nprintUpperCase(\"cactus\");\n// => CACTUS\nprintUpperCase([\"cactus\", \"bear\", \"potato\"]);\n// => CACTUS\n//  BEAR\n//  POTATO\n```\n\n"},"2016-01-02-keys-in-children-components-are-important.md":{"name":"2016-01-02-keys-in-children-components-are-important.md","sha":"822b947abce3b7cd69eb2ba6539fa5f6f7b90da9","content":"---\nlayout: post\n\ntitle: 子容器的Key是很重要的\ntip-number: 02\ntip-username: loverajoel \ntip-username-profile: https://github.com/loverajoel\ntip-tldr: key是必须传递给从数组中动态创建的所有组件的一个值。它是一个唯一且固定的id，用来识别DOM中的每个组件，也可以让我们区别它是否是同一个组件。使用key可以确保子容器是可保存而且不需要重复创建的，还可以防止奇怪的事情发生。\n\ncategories:\n    - zh_CN\n---\n\n[key](https://facebook.github.io/react/docs/multiple-components.html#dynamic-children)必须传递给从数组中动态创建的所有组件的一个值。它是一个唯一且固定的id，用来识别DOM中的每个组件，也可以让我们区别它是否是同一个组件。使用key可以确保子容器是可保存而且不需要重复创建的，还可以防止奇怪的事情发生。\n\n> key跟效率不是很相关，它更与身份有关系（这间接的使效率更好）。随机的赋值或改变值将不能识别身份[Paul O’Shannessy](https://github.com/facebook/react/issues/1342#issuecomment-39230939)\n\n- 使用对象存在的的唯一值。\n- 在父组件定义key,而不是子组件。\n\n```javascript\n//bad\n...\nrender() {\n\t<div key={{item.key}}>{{item.name}}</div>\n}\n...\n\n//good\n<MyComponent key={{item.key}}/>\n```\n- [使用数组索引是一个坏习惯](https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318#.76co046o9)\n- `random()` 不会起作用\n\n```javascript\n//bad\n<MyComponent key={{Math.random()}}/>\n```\n\n- 你可以创建以自己的唯一id。确定这个方法运行速度够快，把它附着到你的对象上。\n- 当子组件的数量很大或者包含重量级的组件时，使用key来提高性能。\n- [你必须提供key值给ReactCSSTransitionGroup的每个子组件](http://docs.reactjs-china.com/react/docs/animation.html)"},"2016-01-07-use-strict-and-get-lazy.md":{"name":"2016-01-07-use-strict-and-get-lazy.md","sha":"5665e6d8425c92606001c7711ed9b5edf792bf97","content":"---\nlayout: post\n\ntitle: 使用\"use strict\" 变得懒惰\ntip-number: 07\ntip-username: nainslie\ntip-username-profile: https://twitter.com/nat5an\ntip-tldr: JavaScript的严格模式使开发者更容易写出“安全”的代码。\n\ncategories:\n    - zh_CN\n---\n\n（译者注：此片翻译较渣，欢迎指正，建议大家[阅读原文](http://www.jstips.co/en/use-strict-and-get-lazy/)或直接阅读[MDN对严格模式的中文介绍](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode) 并欢迎PR）\n\nJavaScript的严格模式使开发者更容易写出“安全”的代码。\n\n通常情况下，JavaScript允许程序员相当粗心，比如你可以引用一个从未用\"var\"声明的变量。或许对于一个刚入门的开发者来说这看起来很方便，但这也是变量拼写错误或者从作用域外引用变量时引发的一系列错误的原因。\n\n程序员喜欢电脑帮我们做一些无聊的工作，喜欢它自动的检查我们工作上的错误。这就是\"use strict\"帮我们做的，它把我们的错误转变为了JavaScript错误。\n\n我们把这个指令放在js文件顶端来使用它:\n\n```javascript\n// 全脚本严格模式\n\"use strict\";\nvar v = \"Hi!  I'm a strict mode script!\";\n```\n\n\n或者放在一个方法内：\n\n```javascript\nfunction f()\n{\n\n  // 方法级严格模式\n  'use strict';\n  function nested() { return \"And so am I!\"; }\n  return \"Hi!  I'm a strict mode function!  \" + nested();\n}\nfunction f2() { return \"I'm not strict.\"; }\n```\n\n\n通过在JavaScript文件或方法内引入此指令，使JavaScript引擎运行在严格模式下，这直接禁止了许多大项目中不受欢迎的操作。另外，严格模式也改变了以下行为：\n* 只有被\"var\"声明过的变量才可以引用。\n* 试图写只读变量时将会报错\n* 只能通过\"new\"关键字调用构造方法\n* \"this\"不再隐式的指向全局变量\n* 对eval()有更严格的限制\n* 防止你使用预保留关键字命名变量\n\n严格模式对于新项目来说是很棒的，但对于一些并没有使用它的老项目来说，引入它也是很有挑战性的。如果你把所有js文件都连接到一个大文件中的话，可能导致所有文件都运行在严格模式下，这可能也会有一些问题。\n\nIt is not a statement, but a literal expression, ignored by earlier versions of JavaScript.\n严格模式的支持情况:\n* Internet Explorer from version 10.\n* Firefox from version 4.\n* Chrome from version 13.\n* Safari from version 5.1.\n* Opera from version 12.\n\n\n[MDN对严格模式的全面介绍](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)\n"},"2016-01-08-converting-a-node-list-to-an-array.md":{"name":"2016-01-08-converting-a-node-list-to-an-array.md","sha":"119c7262684189779a6ff0273a414f8da1a085f8","content":"---\nlayout: post\n\ntitle: 将Node List转换为数组(Array)\ntip-number: 08\ntip-username: Tevko\ntip-username-profile: https://twitter.com/tevko\ntip-tldr: 这是一个快速、安全、可重用的方法将node list转换为DOM元素的数组。\n\ncategories:\n    - zh_CN\n---\n\n`querySelectorAll`方法返回一个类数组对象称为node list。这些数据结构被称为“类数组”，因为他们看似数组却没有类似`map`、`foreach`这样的数组方法。这是一个快速、安全、可重用的方法将node list转换为DOM元素的数组：\n\n```javascript\nconst nodelist = document.querySelectorAll('div');\nconst nodelistToArray = Array.apply(null, nodelist);\n\n\n//之后 ..\n\nnodelistToArray.forEach(...);\nnodelistToArray.map(...);\nnodelistToArray.slice(...);\n\n\n//等...\n```\n\n`apply`方法可以在指定`this`时以数组形式向方法传递参数。[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)规定`apply`可以接受类数组对象,恰巧就是`querySelectorAll`方法所返回的内容。如果我们不需要指定方法内`this`的值时传`null`或`0`即可。返回的结果即包含所有数组方法的DOM元素数组。\n\n如果你正在用ES2015你可以使用[展开运算符 `...`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator)\n\n```js\nconst nodelist = [...document.querySelectorAll('div')]; // 返回一个真正的数组\n\n//之后 ..\n\nnodelist.forEach(...);\nnodelist.map(...);\nnodelist.slice(...);\n\n\n//等...\n```\n"},"2016-01-11-hoisting.md":{"name":"2016-01-11-hoisting.md","sha":"ead0a93dc7d0c2d7966d80b646e1cb5e72935895","content":"---\nlayout: post\n\ntitle: 变量提升\ntip-number: 11\ntip-username: squizzleflip\ntip-username-profile: https://twitter.com/squizzleflip\ntip-tldr: JavaScript模块和构建步骤越来越复杂和多样化，但是新框架里的样板是什么样子的呢？\n\ncategories:\n    - zh_CN\n---\n\n理解[变量提升](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var#var_hoisting)可以帮助你组织方法作用域。只要记住变量声明和方法声明都会被提升到顶部。变量的定义不会提升，即使你在同一行声明和定义一个变量。变量**声明**是让系统知道有这个变量存在而**定义**是给其赋值。\n\n```javascript\nfunction doTheThing() {\n  // ReferenceError: notDeclared is not defined\n  console.log(notDeclared);\n\n  // Outputs: undefined\n  console.log(definedLater);\n  var definedLater;\n\n  definedLater = 'I am defined!'\n  // Outputs: 'I am defined!'\n  console.log(definedLater)\n\n  // Outputs: undefined\n  console.log(definedSimulateneously);\n  var definedSimulateneously = 'I am defined!'\n  // Outputs: 'I am defined!'\n  console.log(definedSimulateneously)\n\n  // Outputs: 'I did it!'\n  doSomethingElse();\n\n  function doSomethingElse(){\n    console.log('I did it!');\n  }\n\n  // TypeError: undefined is not a function\n  functionVar();\n\n  var functionVar = function(){\n    console.log('I did it!');\n  }\n}\n```\n\n\n为了让你的代码更易读，将所有的变量声明在函数的顶端，这样可以更清楚的知道变量来自哪个作用域。在使用变量之前声明变量。将方法定义在函数的底部。\n"},"2016-01-09-template-strings.md":{"name":"2016-01-09-template-strings.md","sha":"c1093b1cb316f4d2219bc23022c8dd67cf3f32e2","content":"---\nlayout: post\n\ntitle: 模板字符串\ntip-number: 09\ntip-username: JakeRawr\ntip-username-profile: https://github.com/JakeRawr\ntip-tldr: ES6中，JS现在有了引号拼接字符串的替代品，模板字符串。\n\ncategories:\n    - zh_CN\n---\n\n\nES6中，JS现在有了引号拼接字符串的替代品，模板字符串。\n\n示例:\n普通字符串\n```javascript\nvar firstName = 'Jake';\nvar lastName = 'Rawr';\nconsole.log('My name is ' + firstName + ' ' + lastName);\n// My name is Jake Rawr\n```\n\n模板字符串\n```javascript\nvar firstName = 'Jake';\nvar lastName = 'Rawr';\nconsole.log(`My name is ${firstName} ${lastName}`);\n// My name is Jake Rawr\n```\n\n\n在模板字符串中，你可以不用`\\n`来生成多行字符串还可以在`${}`里做简单的逻辑运算（例如 2+3）。\n\n你也可以使用方法修改模板字符串的输出内容；他们被称为[带标签的模板字符串](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/template_strings#Tagged_template_strings)（其中有带标签的模板字符串的示例）\n\n或许你还想[阅读更多内容](https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2)来了解模板字符串。\n"},"2016-01-26-filtering-and-sorting-a-list-of-strings.md":{"name":"2016-01-26-filtering-and-sorting-a-list-of-strings.md","sha":"5f49794695f42e3b51ec77f08f14cb7755f74a08","content":"---\nlayout: post\n\ntitle: 过滤并排序字符串列表\ntip-number: 26\ntip-username: davegomez\ntip-username-profile: https://github.com/davegomez\ntip-tldr: 你可能有一个很多名字组成的列表，需要过滤掉重复的名字并按字母表将其排序。\n\ncategories:\n    - zh_CN\n---\n\n你可能有一个很多名字组成的列表，需要过滤掉重复的名字并按字母表将其排序。\n\n在我们的例子里准备用不同版本语言的**JavaScript 保留字**的列表，但是你能发现，有很多重复的关键字而且它们并没有按字母表顺序排列。所以这是一个完美的字符串列表([数组](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array))来测试我们的JavaScript小知识。\n\n```js\nvar keywords = ['do', 'if', 'in', 'for', 'new', 'try', 'var', 'case', 'else', 'enum', 'null', 'this', 'true', 'void', 'with', 'break', 'catch', 'class', 'const', 'false', 'super', 'throw', 'while', 'delete', 'export', 'import', 'return', 'switch', 'typeof', 'default', 'extends', 'finally', 'continue', 'debugger', 'function', 'do', 'if', 'in', 'for', 'int', 'new', 'try', 'var', 'byte', 'case', 'char', 'else', 'enum', 'goto', 'long', 'null', 'this', 'true', 'void', 'with', 'break', 'catch', 'class', 'const', 'false', 'final', 'float', 'short', 'super', 'throw', 'while', 'delete', 'double', 'export', 'import', 'native', 'public', 'return', 'static', 'switch', 'throws', 'typeof', 'boolean', 'default', 'extends', 'finally', 'package', 'private', 'abstract', 'continue', 'debugger', 'function', 'volatile', 'interface', 'protected', 'transient', 'implements', 'instanceof', 'synchronized', 'do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case', 'else', 'enum', 'eval', 'null', 'this', 'true', 'void', 'with', 'break', 'catch', 'class', 'const', 'false', 'super', 'throw', 'while', 'yield', 'delete', 'export', 'import', 'public', 'return', 'static', 'switch', 'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue', 'debugger', 'function', 'arguments', 'interface', 'protected', 'implements', 'instanceof', 'do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case', 'else', 'enum', 'eval', 'null', 'this', 'true', 'void', 'with', 'await', 'break', 'catch', 'class', 'const', 'false', 'super', 'throw', 'while', 'yield', 'delete', 'export', 'import', 'public', 'return', 'static', 'switch', 'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue', 'debugger', 'function', 'arguments', 'interface', 'protected', 'implements', 'instanceof'];\n```\n\n因为我们不想改变我们的原始列表，所以我们准备用高阶函数叫做[`filter`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)，它将基于我们传递的回调方法返回一个新的过滤后的数组。回调方法将比较当前关键字在原始列表里的索引和新列表中的索引，仅当索引匹配时将当前关键字push到新数组。\n\n最后我们准备使用[`sort`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)方法排序过滤后的列表，`sort`只接受一个比较方法作为参数，并返回按字母表排序后的列表。\n\n```js\nvar filteredAndSortedKeywords = keywords\n  .filter(function (keyword, index) {\n      return keywords.lastIndexOf(keyword) === index;\n    })\n  .sort(function (a, b) {\n      return a < b ? -1 : 1;\n    });\n```\n\n在**ES6** (ECMAScript 2015)版本下使用[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)看起来更简单:\n\n```js\nconst filteredAndSortedKeywords = keywords\n  .filter((keyword, index) => keywords.lastIndexOf(keyword) === index)\n  .sort((a, b) => a < b ? -1 : 1);\n```\n\n这是最后过滤和排序后的JavaScript保留字列表：\n\n```js\nconsole.log(filteredAndSortedKeywords);\n\n// ['abstract', 'arguments', 'await', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'double', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'final', 'finally', 'float', 'for', 'function', 'goto', 'if', 'implements', 'import', 'in', 'instanceof', 'int', 'interface', 'let', 'long', 'native', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'short', 'static', 'super', 'switch', 'synchronized', 'this', 'throw', 'throws', 'transient', 'true', 'try', 'typeof', 'var', 'void', 'volatile', 'while', 'with', 'yield']\n```\n\n*感谢[@nikshulipa](https://github.com/nikshulipa)、[@kirilloid](https://twitter.com/kirilloid)、[@lesterzone](https://twitter.com/lesterzone)、[@tracker1](https://twitter.com/tracker1)、[@manuel_del_pozo](https://twitter.com/manuel_del_pozo)所有的回复与建议！*\n"},"2016-01-23-converting-to-number-fast-way.md":{"name":"2016-01-23-converting-to-number-fast-way.md","sha":"0d0aaff14ae08adfbecaa541a7ac29a2ea45052b","content":"---\nlayout: post\n\ntitle: 转换为数字的更快方法\ntip-number: 23\ntip-username: sonnyt\ntip-username-profile: http://twitter.com/sonnyt\ntip-tldr: 将字符串转换为数字是极为常见的。最简单和快速的方法是使用`+`(加号) 来实现。\n\ncategories:\n    - zh_CN\n---\n\n将字符串转换为数字是极为常见的。最简单和快速的方法([jsPref](https://jsperf.com/number-vs-parseint-vs-plus/29))`+`(加号) 来实现。\n\n```javascript\nvar one = '1';\n\nvar numberOne = +one; // Number 1\n```\n\n你也可以用`-`(减号)将其转化为负数值。\n\n```javascript\nvar one = '1';\n\nvar negativeNumberOne = -one; // Number -1\n```\n"},"2016-01-13-tip-to-measure-performance-of-a-javascript-block.md":{"name":"2016-01-13-tip-to-measure-performance-of-a-javascript-block.md","sha":"37ca6d8f57a3cd783b7a5720dbe266482e079290","content":"---\nlayout: post\n\ntitle:  测量javascript代码块性能的小知识\ntip-number: 13\ntip-username: manmadareddy\ntip-username-profile: https://twitter.com/manmadareddy\ntip-tldr: 快速的测量javascript的性能，我们可以使用console的方法，例如 ```console.time(label)```和 ```console.timeEnd(label)```\n\ncategories:\n    - zh_CN\n---\n\n快速的测量javascript的性能，我们可以使用console的方法，例如\n[```console.time(label)```](https://developer.chrome.com/devtools/docs/console-api#consoletimelabel) 和 [```console.timeEnd(label)```](https://developer.chrome.com/devtools/docs/console-api#consoletimeendlabel)\n\n\n```javascript\nconsole.time(\"Array initialize\");\nvar arr = new Array(100),\n    len = arr.length,\n    i;\n\nfor (i = 0; i < len; i++) {\n    arr[i] = new Object();\n};\nconsole.timeEnd(\"Array initialize\"); // Outputs: Array initialize: 0.711ms\n```\n\n\n更多内容:\n[Console object](https://github.com/DeveloperToolsWG/console-object),\n[Javascript benchmarking](https://mathiasbynens.be/notes/javascript-benchmarking)\n\nDemo: [jsfiddle](https://jsfiddle.net/meottb62/) - [codepen](http://codepen.io/anon/pen/JGJPoa) (在浏览器控制台输出)\n\n"},"2016-01-20-return-objects-to-enable-chaining-of-functions.md":{"name":"2016-01-20-return-objects-to-enable-chaining-of-functions.md","sha":"5cd71bb3424b22d2658cacdc5e8131c943a20c2b","content":"---\nlayout: post\n\ntitle: 返回对象，使方法可以链式调用\ntip-number: 20\ntip-username: WakeskaterX\ntip-username-profile: https://twitter.com/WakeStudio\ntip-tldr: 在面向对象的Javascript中为对象建立一个方法时，返回当前对象可以让你在一条链上调用方法。\n\ncategories:\n    - zh_CN\n---\n\n在面向对象的Javascript中为对象建立一个方法时，返回当前对象可以让你在一条链上调用方法。\n\n```js\nfunction Person(name) {\n  this.name = name;\n\n  this.sayName = function() {\n    console.log(\"Hello my name is: \", this.name);\n    return this;\n  };\n\n  this.changeName = function(name) {\n    this.name = name;\n    return this;\n  };\n}\n\nvar person = new Person(\"John\");\nperson.sayName().changeName(\"Timmy\").sayName();\n```\n"},"2016-01-14-fat-arrow-functions.md":{"name":"2016-01-14-fat-arrow-functions.md","sha":"809ad7a5fbcad7ef2a3c2d2870dbd60cf3f91de8","content":"---\nlayout: post\n\ntitle: 箭头函数\ntip-number: 14\ntip-username: pklinger\ntip-username-profile: https://github.com/pklinger/\ntip-tldr: 介绍一个ES6的新特性，箭头函数或许一个让你用更少行写更多代码的方便工具。\n\ncategories:\n    - zh_CN\n---\n\n\n介绍一个ES6的新特性，箭头函数或许一个让你用更少行写更多代码的方便工具。它的名字(fat arrow functions)来自于它的语法`=>`是一个比瘦箭头`->`要'胖的箭头'（译者注：但是国内貌似不分胖瘦就叫箭头函数）。Some programmers might already know this type of functions from different languages such as Haskell as 'lambda expressions' respectively 'anonymous functions'. It is called anonymous, as these arrow functions do not have a descriptive function name.（译者注：一些其他语言中的箭头函数，避免不准确就不翻译了 欢迎PR）\n\n### 有什么益处呢?\n* 语法: 更少的代码行; 不再需要一遍一遍的打`function`了\n* 语义: 从上下文中捕获`this`关键字\n\n### 简单的语法示例\n观察一下这两个功能完全相同的代码片段。你将很快明白箭头函数做了什么。\n\n```javascript\n// 箭头函数的一般语法\nparam => expression\n\n// 也可以用用小括号\n// 多参数时小括号是必须的\n(param1 [, param2]) => expression\n\n\n// 使用functions\nvar arr = [5,3,2,9,1];\nvar arrFunc = arr.map(function(x) {\n  return x * x;\n});\nconsole.log(arr)\n\n// 使用箭头函数\nvar arr = [5,3,2,9,1];\nvar arrFunc = arr.map((x) => x*x);\nconsole.log(arr)\n```\n\n正如你所看到的，箭头函数在这种情况下省去了写小括号，function以及return的时间。我建议你总是使用小括号，因为对于像`(x,y) => x+y`这样多参数函数，小括号总是需要的。这仅是以防在不同使用场景下忘记小括号的一种方法。但是上面的代码和`x => x*x`是一样的。至此仅是语法上的提升，减少了代码行数并提高了可读性。\n\n### Lexically binding `this`\n\n这是另一个使用箭头函数的好原因。这是一个关于`this`上下文的问题。使用箭头函数，你不需要再担心`.bind(this)`也不用再设置`that = this`了，因为箭头函数继承了外围作用域的`this`值。看一下下面的[示例](https://jsfiddle.net/pklinger/rw94oc11/):\n\n```javascript\n\n// 全局定义 this.i\nthis.i = 100;\n\nvar counterA = new CounterA();\nvar counterB = new CounterB();\nvar counterC = new CounterC();\nvar counterD = new CounterD();\n\n// 不好的例子\nfunction CounterA() {\n  // CounterA的`this`实例 (!!调用时忽略了此实例)\n  this.i = 0;\n  setInterval(function () {\n    // `this` 指向全局(global)对象,而不是CounterA的`this`\n    // 所以从100开始计数,而不是0 (本地的this.i)\n    this.i++;\n    document.getElementById(\"counterA\").innerHTML = this.i;\n  }, 500);\n}\n\n// 手动绑定 that = this\nfunction CounterB() {\n  this.i = 0;\n  var that = this;\n  setInterval(function() {\n    that.i++;\n    document.getElementById(\"counterB\").innerHTML = that.i;\n  }, 500);\n}\n\n// 使用 .bind(this)\nfunction CounterC() {\n  this.i = 0;\n  setInterval(function() {\n    this.i++;\n    document.getElementById(\"counterC\").innerHTML = this.i;\n  }.bind(this), 500);\n}\n\n// 箭头函数\nfunction CounterD() {\n  this.i = 0;\n  setInterval(() => {\n    this.i++;\n    document.getElementById(\"counterD\").innerHTML = this.i;\n  }, 500);\n}\n```\n\n更多有关箭头函数的内容可以查看[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)。更多语法选项请看[这里](http://jsrocks.org/2014/10/arrow-functions-and-their-scope/).\n\n"},"2016-01-12-pseudomandatory-parameters-in-es6-functions.md":{"name":"2016-01-12-pseudomandatory-parameters-in-es6-functions.md","sha":"7ac58124f5612f5b5e2cc03a92deb46352b204dd","content":"---\nlayout: post\n\ntitle: ES6中的伪强制参数\ntip-number: 12\ntip-username: Avraam Mavridis\ntip-username-profile: https://github.com/AvraamMavridis\ntip-tldr: 在许多编程语言中，方法的参数时默认强制需要的，开发人员需要明确定义一个可选的参数。\n\ncategories:\n    - zh_CN\n---\n\n在许多编程语言中，方法的参数时默认强制需要的，开发人员需要明确定义一个可选的参数。在Javascript中任何参数都是可选的，但是我们可以利用[**es6参数默认值**](http://exploringjs.com/es6/ch_parameter-handling.html#sec_parameter-default-values)特性的优点来实现强制要求这种表现而不污染本身的函数体。\n\n```javascript\nconst _err = function( message ){\n  throw new Error( message );\n}\n\nconst getSum = (a = _err('a is not defined'), b = _err('b is not defined')) => a + b\n\ngetSum( 10 ) // throws Error, b is not defined\ngetSum( undefined, 10 ) // throws Error, a is not defined\n ```\n\n\n\n `_err`方法会立即抛出一个错误。如果没有传递值给参数，默认值将会被使用, `_err`方法将被调用而错误也将被抛出。你可以从[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters)看到更多关于**默认参数特性**的例子。 \n"},"2016-01-18-rounding-the-fast-way.md":{"name":"2016-01-18-rounding-the-fast-way.md","sha":"4ad669d3e2d6d2f3a7a896e62e38b60d44ee3d52","content":"---\nlayout: post\n\ntitle: 快速（但危险）的取整方法\ntip-number: 18\ntip-username: pklinger\ntip-username-profile: https://github.com/pklinger\ntip-tldr: 通常情况下`~~X`比`Math.trunc(X)`要快，但同时也会使你的代码做一些讨厌的事情。\n\ncategories:\n    - zh_CN\n---\n\n本条小知识关于性能...\n\n你曾遇到过[双波浪线`~~`操作符](http://stackoverflow.com/questions/5971645/what-is-the-double-tilde-operator-in-javascript)吗？它也被称为“双按位非”操作符。你通常可以使用它作为代替`Math.trunc()`的更快的方法。为什么呢？\n\n一个按位非操作符`~`首先将输入`input`截取为32位，然后将其转换为`-(input+1)`。因此双按位非操作符将输入转换为`-(-(input + 1)+1)`，使其成为一个趋向于0取整的好工具。对于数字的输入，它很像`Math.trunc()`。失败时返回`0`,这可能在解决`Math.trunc()`转换错误返回`NaN`时是一个很好的替代。\n\n```js\n// 单个 ~\nconsole.log(~1337)    // -1338\n\n// 数字输入\nconsole.log(~~47.11)  // -> 47\nconsole.log(~~1.9999) // -> 1\nconsole.log(~~3)      // -> 3\n```\n\n然而, 尽管`~~`可能有更好的性能，有经验的程序员通常坚持使用`Math.trunc()`。要明白为什么，这里有一个关于此操作符的冷静分析。\n\n### 适用的情况\n\n##### 当CPU资源很珍贵时\n`~~`可能在各平台上都比`Math.trunc()`快，但是你应该在你所关心的所有平台上[测试这种猜想](https://jsperf.com/jsfvsbitnot/10)。同样，你通常需要执行数百万这样的操作来看看在运行时有没有明显的影响。\n\n##### 当不需要关心代码清晰度时\n如果你想迷惑其他人，或者想在`minifier/uglifier`时取得更大功效，这是一种相对廉价的方式。\n\n### 禁用的情况\n\n##### 当你的代码需要维护时\n代码可读性始终是最重要的。无论你工作在一个团队，或是贡献给开源仓库，或是单飞。正如[名言所说](http://c2.com/cgi/wiki?CodeForTheMaintainer)：\n> Always code as if the person who ends up maintaining your code is a violent psychopath who knows where you live.(写代码时，要始终认为一个有暴力倾向并知道你住在哪里的人会最终维护你的代码。)\n\nFor a solo programmer, that psychopath is inevitably \"you in six months\".（这句不会翻译……）\n\n##### 当你忘记`~~`永远趋向于0时\n新手程序员或许更关注`~~`的聪明之处，却忘记了“只去掉小数部分”的意义。这在将浮点数转换为数组索引或关联有序的值时很容易导致**差一错误** ，这时明显需要一个不同的取整方法。 （代码可读性不高往往会导致此问题）\n\n打个比方，如果你想得到离一个数“最近的整数”，你应该用`Math.round()`而不是`~~`，但是由于程序员的惰性和**_每次使用需要敲10个键_**的事实，人类的手指往往会战胜冷冷的逻辑，导致错误的结果。\n\n相比之下，`Math.xyz()`（举例）函数的名字清楚的传达了它们的作用，减少了可能出现的意外的错误。\n\n##### 当处理大数时\n因为`~`首先将数组转换为32位，`~~`的结果伪值在 &plusmn;2.15*10^12左右。如果你没有明确的检查输入值的范围，当转换的值最终与原始值有很大差距时，用户就可能触发未知的行为：\n\n```js\na = 2147483647.123  // 比32位最大正数，再多一点\nconsole.log(~~a)    // ->  2147483647     (ok)\na += 10000          // ->  2147493647.123 (ok)\nconsole.log(~~a)    // -> -2147483648     (huh?)\n```\n\n一个特别容易中招的地方是在处理Unix时间戳时(从1970年1月1日 00:00:00 UTC开始以秒测量)。一个快速获取的方法:\n\n```js\nepoch_int = ~~(+new Date() / 1000)  // Date() 以毫秒计量，所以我们缩小它\n```\n\n然而，当处理2038年1月19日 03:14:07 UTC 之后的时间戳时（有时称为**Y2038 limit**）, 可怕的事情发生了：\n\n```js\n// 2040年1月1日 00:00:00.123 UTC的时间戳\nepoch = +new Date('2040-01-01') / 1000 + 0.123  // ->  2208988800.123\n\n// 回到未来!\nepoch_int = ~~epoch                                 // -> -2085978496\nconsole.log(new Date(epoch_int * 1000))             // ->  Wed Nov 25 1903 17:31:44 UTC\n\n// 这很搞笑，让我们来取得正确答案\nepoch_flr = Math.floor(epoch)                       // ->  2208988800\nconsole.log(new Date(epoch_flr * 1000))             // ->  Sun Jan 01 2040 00:00:00 UTC\n```\n\n##### 当原始输入的数据类型不确定时\n因为`~~`可以将任何非数字类型转换为`0`：\n\n```js\nconsole.log(~~[])   // -> 0\nconsole.log(~~NaN)  // -> 0\nconsole.log(~~null) // -> 0\n```\n\n一些程序员将其看作适当输入验证的替代品。然而，这将导致奇怪的逻辑问题，因此你不能辨别违法输入还是真正的`0`。因此这_并不_推荐。\n\n##### 当很多人认为`~~X == Math.floor(X)`时\n很多人由于很多原因错误的把\"双按位非\"等同于`Math.floor()`。如果你不能准确地使用它，最终你很有可能会滥用它。\n\n另一些人很细心的注意正数使用`Math.floor()`而负数使用`Math.ceil()`，但这又强制你在处理它的时候需要停下来想一想你处理的数是什么值。这又违背了使用`~~`快捷无陷阱的目的。\n\n### 结论\n尽量避免，并有节制的使用。\n\n### 使用\n1. 谨慎使用。\n2. 在应用前检查值。\n3. 仔细记录被转化值的相关假设。\n4. 审查代码至少处理：\n   * 逻辑错误，不合法的输入作为合法的`0`穿入其他代码模块\n   * 输入转换后范围错误\n   * 错误的舍入方向导致差一错误\n"},"2016-01-19-safe-string-concatenation.md":{"name":"2016-01-19-safe-string-concatenation.md","sha":"78ede216ca2ed7a7f171473857098f6e9be74683","content":"---\nlayout: post\n\ntitle: 安全的字符串拼接\ntip-number: 19\ntip-username: gogainda\ntip-username-profile: https://twitter.com/gogainda\ntip-tldr: 假如你需要拼接一些不确定类型的变量为字符串，你需要确保算术运算符在你拼接时不会起作用。使用concat\n\ncategories:\n    - zh_CN\n---\n\n假如你需要拼接一些不确定类型的变量为字符串，你需要确保算术运算符在你拼接时不会起作用。使用concat：\n\n```javascript\nvar one = 1;\nvar two = 2;\nvar three = '3';\n\nvar result = ''.concat(one, two, three); //\"123\"\n```\n\n这应该就是你所期望的拼接结果。如果不这样，拼接时加号可能会导致你意想不到的结果：\n\n```javascript\nvar one = 1;\nvar two = 2;\nvar three = '3';\n\nvar result = one + two + three; //\"33\" instead of \"123\"\n```\n\n关于性能,与用[```join```](http://www.sitepoint.com/javascript-fast-string-concatenation/)来拼接字符串相比 ```concat```的效率是几乎一样的。\n\n你可以在[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)了解更多关于```concat```方法的内容。\n"},"2016-01-17-nodejs-run-a-module-if-it-is-not-required.md":{"name":"2016-01-17-nodejs-run-a-module-if-it-is-not-required.md","sha":"817e86e3d2b3b41a7c8bf192b35f2cc0cfb3e779","content":"---\nlayout: post\n\ntitle: Node.js - 运行未被引用的模块\ntip-number: 17\ntip-username: odsdq\ntip-username-profile: https://twitter.com/odsdq\ntip-tldr: 在Node里,你可以让你的程序根据其运行自`require('./something.js')`或者`node something.js`而做不同的处理。如果你想与你的一个独立的模块进行交互，这是非常有用的。\n\ncategories:\n    - zh_CN\n---\n\n在Node里,你可以让你的程序根据其运行自`require('./something.js')`或者`node something.js`而做不同的处理。如果你想与你的一个独立的模块进行交互，这是非常有用的。\n\n```js\nif (!module.parent) {\n    // 通过 `node something.js` 启动\n    app.listen(8088, function() {\n        console.log('app listening on port 8088');\n    })\n} else {\n    // 通过 `require('/.something.js')` 被引用\n    module.exports = app;\n}\n```\n\n更多内容请看 [modules的文档](https://nodejs.org/api/modules.html#modules_module_parent)\n"},"2016-01-21-shuffle-an-array.md":{"name":"2016-01-21-shuffle-an-array.md","sha":"e00495b4bcf1ae51f196413e96e5b844cd951b60","content":"---\nlayout: post\n\ntitle: 对数组洗牌\ntip-number: 21\ntip-username: 0xmtn\ntip-username-profile: https://github.com/0xmtn/\ntip-tldr: Fisher-Yates Shuffling 算法对数组进行洗牌\n\ncategories:\n    - zh_CN\n---\n\n \n 这段代码运用了[Fisher-Yates Shuffling](https://www.wikiwand.com/en/Fisher%E2%80%93Yates_shuffle)算法对数组进行洗牌。\n  \n```javascript\nfunction shuffle(arr) {\n    var i, \n        j,\n        temp;\n    for (i = arr.length - 1; i > 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    return arr;    \n};\n```\n调用示例:\n\n```javascript\nvar a = [1, 2, 3, 4, 5, 6, 7, 8];\nvar b = shuffle(a);\nconsole.log(b);\n// [2, 7, 8, 6, 5, 3, 1, 4]\n```\n"},"2016-01-24-use_===_instead_of_==.md":{"name":"2016-01-24-use_===_instead_of_==.md","sha":"9a76d1836ebfaaa054e6eccb2ed0da6b0d545f6e","content":"---\nlayout: post\n\ntitle: 使用 === 而不是 ==\ntip-number: 24\ntip-username: bhaskarmelkani\ntip-username-profile: https://www.twitter.com/bhaskarmelkani\ntip-tldr: == (或者 `!=`) 操作在需要的情况下自动进行了类型转换。`===` (或 `!==`)操作不会执行任何转换。`===`在比较值和类型时，可以说比`==`更快。\n\ncategories:\n    - zh_CN\n---\n\n`==` (或者 `!=`) 操作在需要的情况下自动进行了类型转换。`===` (或 `!==`)操作不会执行任何转换。`===`在比较值和类型时，可以说比`==`更快([jsPref](http://jsperf.com/strictcompare))。 \n\n```js\n[10] ==  10      // 为 true\n[10] === 10      // 为 false\n\n'10' ==  10      // 为 true\n'10' === 10      // 为 false\n\n []  ==  0       // 为 true\n []  === 0       // 为 false\n\n ''  ==  false   // 为 true 但 true == \"a\" 为false\n ''  === false   // 为 false \n\n```\n"},"2016-01-15-even-simpler-way-of-using-indexof-as-a-contains-clause.md":{"name":"2016-01-15-even-simpler-way-of-using-indexof-as-a-contains-clause.md","sha":"49c919b68c893540383cdb2c71a9b9f56e907015","content":"---\nlayout: post\n\ntitle: 更简单的使用indexOf实现contains功能\ntip-number: 15\ntip-username: jhogoforbroke\ntip-username-profile: https://twitter.com/jhogoforbroke\ntip-tldr: JavaScript并未提供contains方法。检测子字符串是否存在于字符串或者变量是否存在于数组你可能会这样做。\n\ncategories:\n    - zh_CN\n---\n\n\nJavaScript并未提供contains方法。检测子字符串是否存在于字符串或者变量是否存在于数组你可能会这样做：\n\n```javascript\nvar someText = 'javascript rules';\nif (someText.indexOf('javascript') !== -1) {\n}\n\n// or\nif (someText.indexOf('javascript') >= 0) {\n}\n```\n\n但是让我们看一下这些 [Expressjs](https://github.com/strongloop/express)代码段。\n\n[examples/mvc/lib/boot.js](https://github.com/strongloop/express/blob/2f8ac6726fa20ab5b4a05c112c886752868ac8ce/examples/mvc/lib/boot.js#L26)\n```javascript\nfor (var key in obj) {\n  // \"reserved\" exports\n  if (~['name', 'prefix', 'engine', 'before'].indexOf(key)) continue;\n```\n\n[lib/utils.js](https://github.com/strongloop/express/blob/2f8ac6726fa20ab5b4a05c112c886752868ac8ce/lib/utils.js#L93)\n```javascript\nexports.normalizeType = function(type){\n  return ~type.indexOf('/')\n    ? acceptParams(type)\n    : { value: mime.lookup(type), params: {} };\n};\n```\n\n[examples/web-service/index.js](https://github.com/strongloop/express/blob/2f8ac6726fa20ab5b4a05c112c886752868ac8ce/examples/web-service/index.js#L35)\n```javascript\n// key is invalid\nif (!~apiKeys.indexOf(key)) return next(error(401, 'invalid api key'));\n```\n\n难点是 [位操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) **~**, “按位操作符操作数字的二进制形式，但是返回值依然是标准的JavaScript数值。”\n\n它将`-1`转换为`0`,而`0`在javascript为`false`,所以:\n\n```javascript\nvar someText = 'text';\n!!~someText.indexOf('tex'); // someText contains \"tex\" - true\n!~someText.indexOf('tex'); // someText NOT contains \"tex\" - false\n~someText.indexOf('asd'); // someText doesn't contain \"asd\" - false\n~someText.indexOf('ext'); // someText contains \"ext\" - true\n```\n\n### String.prototype.includes()\n\n在ES6中提供了[includes() 方法](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/includes)供我们判断一个字符串是否包含了另一个字符串:\n\n```javascript\n'something'.includes('thing'); // true\n```\n\n在ECMAScript 2016 (ES7)甚至可能将其应用于数组，像indexOf一样:\n\n```javascript\n!!~[1, 2, 3].indexOf(1); // true\n[1, 2, 3].includes(1); // true\n```\n\n**不幸的是, 只有Chrome、Firefox、Safari 9及其更高版本和Edge支持了这功能。IE11及其更低版本并不支持**\n**最好在受控的环境中使用此功能**\n"},"2016-01-27-short-circiut-evaluation-in-js.md":{"name":"2016-01-27-short-circiut-evaluation-in-js.md","sha":"83df232918d90df250764a4c10093d1a4e14fb97","content":"---\nlayout: post\n\ntitle: JS中的短路求值\ntip-number: 27\ntip-username: bhaskarmelkani\ntip-username-profile: https://www.twitter.com/bhaskarmelkani\ntip-tldr: 短路求值是说, 只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值：当AND(`&&`)的第一个运算数的值为false时，其结果必定为false；当OR(`||`)的第一个运算数为true时，最后结果必定为true。\n\ncategories:\n    - zh_CN\n---\n\n[短路求值](https://zh.wikipedia.org/wiki/%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC)是说, 只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值：当AND(`&&`)的第一个运算数的值为false时，其结果必定为false；当OR(`||`)的第一个运算数为true时，最后结果必定为true。\n\n对于下面的`test`条件和`isTrue`与`isFalse`方法\n\n```js\nvar test = true;\nvar isTrue = function(){\n  console.log('Test is true.');\n};\nvar isFalse = function(){\n  console.log('Test is false.');\n};\n\n```\n使用逻辑与 - `&&`.\n\n```js\n// 普通的if语句\nif(test){\n  isTrue();    // Test is true\n}\n\n// 上面的语句可以使用 '&&' 写为：\n\n( test && isTrue() );  // Test is true\n```\n使用逻辑或 - `||`.\n\n```js\ntest = false;\nif(!test){\n  isFalse();    // Test is false.\n}\n\n( test || isFalse());  // Test is false.\n```\n逻辑或可以用来给参数设置默认值。\n\n```js\nfunction theSameOldFoo(name){ \n    name = name || 'Bar' ;\n    console.log(\"My best friend's name is \" + name);\n}\ntheSameOldFoo();  // My best friend's name is Bar\ntheSameOldFoo('Bhaskar');  // My best friend's name is Bhaskar\n```\n逻辑与可以用来避免调用undefined参数的属性时报错\n例如:-\n\n```js\nvar dog = { \n  bark: function(){\n     console.log('Woof Woof');\n   }\n};\n\n// 调用 dog.bark();\ndog.bark(); // Woof Woof.\n\n// 但是当dog未定义时，dog.bark() 将会抛出\"Cannot read property 'bark' of undefined.\" 错误\n// 防止这种情况，我们可以使用 &&.\n\ndog&&dog.bark();   // This will only call dog.bark(), if dog is defined.\n\n```\n"},"2016-01-16-passing-arguments-to-callback-functions.md":{"name":"2016-01-16-passing-arguments-to-callback-functions.md","sha":"211ce681ef0916507fd8da3af13d10ea7a97cd78","content":"---\nlayout: post\n\ntitle: 向回调方法传递参数\ntip-number: 16\ntip-username: minhazav\ntip-username-profile: https://twitter.com/minhazav\ntip-tldr: JavaScript modules and build steps are getting more numerous and complicated, but what about boilerplate in new frameworks?\n\ncategories:\n    - zh_CN\n---\n\n通常下，你并不能给回调函数传递参数。 比如:\n```js\nfunction callback() {\n  console.log('Hi human');\n}\n\ndocument.getElementById('someelem').addEventListener('click', callback);\n```\n你可以借助Javascript闭包的优势来传递参数给回调函数。看这个例子:\n```js\nfunction callback(a, b) {\n  return function() {\n    console.log('sum = ', (a+b));\n  }\n}\n\nvar x = 1, y = 2;\ndocument.getElementById('someelem').addEventListener('click', callback(x, y));\n```\n\n**什么是闭包?**\n闭包是指函数有自由独立的变量。换句话说，定义在闭包中的函数可以“记忆”它创建时候的环境。想了解更多请[参考MDN的文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Closures)。\n\n这种方法使参数`x`和`y`在回调方法被调用时处于其作用域内。\n\n另一个办法是使用`bind`方法。比如:\n```js\nvar alertText = function(text) {\n  alert(text);\n};\n\ndocument.getElementById('someelem').addEventListener('click', alertText.bind(this, 'hello'));\n```\n两种方法之间有着微小的性能差异,请看[jsperf](http://jsperf.com/bind-vs-closure-23).\n"},"2016-02-04-assignment-shorthands.md":{"name":"2016-02-04-assignment-shorthands.md","sha":"6c15db6c6e563d60da4a6308aeb286e5cc9a3990","content":"---\nlayout: post\n\ntitle: 赋值技巧\ntip-number: 35\ntip-username: hsleonis\ntip-username-profile: https://github.com/hsleonis\ntip-tldr: 赋值是很常见的。有时候打字对于我们这些“懒惰的程序员”来说是很费时间的。所以，我们可以使用一些小把戏来使我们的代码更清楚更简单。\n\ncategories:\n    - zh_CN\n---\n\n赋值是很常见的。有时候打字对于我们这些“懒惰的程序员”来说是很费时间的。\n所以，我们可以使用一些小把戏来使我们的代码更清楚更简单。\n\n这类似于使用：\n\n````javascript\nx += 23; // x = x + 23;\ny -= 15; // y = y - 15;\nz *= 10; // z = z * 10;\nk /= 7; // k = k / 7;\np %= 3; // p = p % 3;\nd **= 2; // d = d ** 2;\nm >>= 2; // m = m >> 2;\nn <<= 2; // n = n << 2;\nn ++; // n = n + 1;\nn --; n = n - 1;\n\n````\n\n### `++` 与 `--` 操作符\n\n对于`++`操作符有些特殊。最好用下面的例子解释一下：\n\n````javascript\nvar a = 2;\nvar b = a++;\n// 现在 a == 3  b == 2\n````\n\n`a++`做了如下工作：\n  1. 返回`a`的值\n  2. `a`增加1\n\n但是如果我们想让值先增加呢？这也很容易：\n\n````javascript\nvar a = 2;\nvar b = ++a;\n// 现在a和b都是3\n````\n\n看明白了吗？我将操作符放在了参数_前面_。\n\n`--`操作符除了使值减小外，其他功能是类似的。\n\n### If-else (使用三元运算符)\n\n我们平时会这样写：\n\n````javascript\nvar newValue;\nif(value > 10) \n  newValue = 5;\nelse\n  newValue = 2;\n````\n\n我们可以使用三元运算符是它更简便：\n\n````javascript\nvar newValue = (value > 10) ? 5 : 2;\n````\n\n### 检测Null、Undefined、空\n\n````javascript\nif (variable1 !== null || variable1 !== undefined || variable1 !== '') {\n     var variable2 = variable1;\n}\n````\n\n简便写法：\n\n````javascript\nvar variable2 = variable1  || '';\n````\nP.S.：如果`variable1`是一个数字，则先检查他是否为0。\n\n### 对象数组表示法\n\n不要用：\n\n````javascript\nvar a = new Array();\na[0] = \"myString1\";\na[1] = \"myString2\";\n````\n使用：\n\n````javascript\nvar a = [\"myString1\", \"myString2\"];\n````\n\n### 关联数组\n\n不要用：\n\n````javascript\nvar skillSet = new Array();\nskillSet['Document language'] = 'HTML5';\nskillSet['Styling language'] = 'CSS3';\n````\n\n使用：\n\n````javascript\nvar skillSet = {\n    'Document language' : 'HTML5', \n    'Styling language' : 'CSS3'\n};\n````\n"},"2016-02-12-use-destructuring-in-function-parameters.md":{"name":"2016-02-12-use-destructuring-in-function-parameters.md","sha":"f4e9defaed39e0e30bab2597ccc82486661a26f3","content":"---\nlayout: post\n\ntitle: 函数参数内使用解构\ntip-number: 43\ntip-username: dislick \ntip-username-profile: https://github.com/dislick\ntip-tldr: 你知道在函数参数内也可以使用解构吗？\n\ncategories:\n    - zh_CN\n---\n\n大家一定对[ES6解构赋值](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)非常熟悉。但是你知道在函数参数里也可以使用它吗？\n\n```javascript\nvar sayHello = function({ name, surname }) {\n  console.log(`Hello ${name} ${surname}! How are you?`);\n};\n\nsayHello({\n  name: 'John',\n  surname: 'Smith'\n});\n```\n\n这对于接收可选参数的函数，是很棒的。\n\n> 请注意解构赋值在Node.js和大部分浏览器中仍然不可用。但是想自己尝试的话可以在Node.js下使用`--harmony-destructuring`标记。"},"2016-01-25-Using-immediately-invoked-function-expression.md":{"name":"2016-01-25-Using-immediately-invoked-function-expression.md","sha":"a33e4cda78cfe7e4b7e3f96f880ac8e1d25df125","content":"---\nlayout: post\n\ntitle: 使用立即执行函数表达式\ntip-number: 25\ntip-username: rishantagarwal \ntip-username-profile: https://github.com/rishantagarwal\ntip-tldr: 立即执行函数表达式( IIFE - immediately invoked function expression)是一个立即执行的匿名函数表达式，它在Javascript中有一些很重要的用途。\n\n\ncategories:\n    - zh_CN\n---\n\n立即执行函数表达式( IIFE - immediately invoked function expression)是一个立即执行的匿名函数表达式，它在Javascript中有一些很重要的用途。\n\n```javascript\n\n(function() {\n // Do something​\n }\n)()\n\n```\n\n这是一个立即执行的匿名函数表达式，它在有JavaScript一些特别重要的用途。\n\n两对括号包裹着一个匿名函数，使匿名函数变成了一个函数表达式。于是，我们现在拥有了一个未命名的函数表达式，而不是一个全局作用域下或在任何地方定义的的简单函数。\n\n类似地，我们也可以创建一个命名过的立即执行函数表达式：\n\n```javascript\n(someNamedFunction = function(msg) {\n\tconsole.log(msg || \"Nothing for today !!\")\n\t}) (); // 输出 --> Nothing for today !!​\n​\nsomeNamedFunction(\"Javascript rocks !!\"); // 输出 --> Javascript rocks !!\nsomeNamedFunction(); // 输出 --> Nothing for today !!​\n```\n\n更多内容, 请参考下面链接 - \n1. [链接 1](https://blog.mariusschulz.com/2016/01/13/disassembling-javascripts-iife-syntax) \n2. [链接 2](http://javascriptissexy.com/12-simple-yet-powerful-javascript-tips/) \n\n效率:\n[jsPerf](http://jsperf.com/iife-with-call)"},"2016-01-31-avoid-modifying-or-passing-arguments-into-other-functions—it-kills-optimization.md":{"name":"2016-01-31-avoid-modifying-or-passing-arguments-into-other-functions—it-kills-optimization.md","sha":"e983870c00e6cdf3cffff1ca34dea4610bef294c","content":"---\nlayout: post\n\ntitle: 避免修改和传递`arguments`给其他方法 — 影响优化\ntip-number: 31\ntip-username: berkana\ntip-username-profile: https://github.com/berkana\ntip-tldr: 在JavaScript的方法里，`arguments`参数可以让你访问传递给该方法的所有参数。`arguments`是一个*类数组对象*；`arguments`可是使用数组标记访问，而且它有*length*参数，但是它没有`filter`、`map`和`forEach`这样内建到数组内的方法。因此，如下代码是一个非常常见的将`arguments`转换为数组的办法\n\n\ncategories:\n    - zh_CN\n---\n\n### 背景\n\n在JavaScript的方法里，[`arguments`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments)参数可以让你访问传递给该方法的所有参数。`arguments`是一个*类数组对象*；`arguments`可是使用数组标记访问，而且它有*length*参数，但是它没有`filter`、`map`和`forEach`这样内建到数组内的方法。因此，如下代码是一个非常常见的将`arguments`转换为数组的办法：\n\n```js\nvar args = Array.prototype.slice.call(arguments);\n```\n将`arguments`传递给`Array`原型(prototype)上的`slice`方法；`slice`方法返回一个对`arguments`浅复制后的数组对象。更短的写法：\n\n```js\nvar args = [].slice.call(arguments);\n```\n在这里，简单的调用了空数组的`slice`方法，而没有从`Array`的原型(prototype)上调用。\n\n### 系统优化\n\n不幸的是，传递`arguments`给任何参数，将导致Chrome和Node中使用的V8引擎跳过对其的优化，这也将使性能相当慢。看一下这篇文章[optimization killers](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers)。传递`arguments`给任何方法被称为*leaking `arguments`*。\n\n如果你想用一个包含参数(arguments)的数组，你需要求助于这个办法：\n\n```js\nvar args = new Array(arguments.length);\nfor(var i = 0; i < args.length; ++i) {\n  args[i] = arguments[i];\n}\n```\n\n没错，这很啰嗦，但是在生产环境中的代码里，为了系统性能优化，这是值得的。"},"2016-02-03-implementing-asynchronous-loops.md":{"name":"2016-02-03-implementing-asynchronous-loops.md","sha":"8275a520ee1770a408d6f03cfcb437623f8deaff","content":"---\nlayout: post\n\ntitle: 实现异步循环\ntip-number: 34\ntip-username: madmantalking\ntip-username-profile: https://github.com/madmantalking\ntip-tldr: 实现异步循环时，你可能会遇到问题。 \n\ncategories:\n    - zh_CN\n---\n\n让我们试着写一个异步方法，每秒打印一次循环的索引值。\n\n```js\nfor (var i=0; i<5; i++) {\n\tsetTimeout(function(){\n\t\tconsole.log(i); \n\t}, 1000 * (i+1));\n}  \n```\n\n如上程序的输出为：\n\n```js\n> 5\n> 5\n> 5\n> 5\n> 5\n```\n\n这明显是有问题的。\n\n**原因**\n\n每次时间结束(timeout)都指向原始的`i`，而并非它的拷贝。所以，for循环使`i`增长到5，之后`timeout`运行并调用了当前`i`的值（也就是5）。\n\n好吧，这个问题看起来很简单。最直接的解决方法是将循环的索引缓存在一个临时变量里。\n\n```js\nfor (var i=0; i<5; i++) {\n\tvar temp = i;\n \tsetTimeout(function(){\n\t\tconsole.log(temp); \n\t}, 1000 * (i+1));\n}  \n```\n\n但是再次运行，如上的程序输出为：\n\n```js\n> 4\n> 4\n> 4\n> 4\n> 4\n```\n\n这仍然有问题，这是因为并不存在块作用域，而且变量的声明被提升到了作用域顶端。实际上，如上代码和下面是一样的：\n\n```js\nvar temp;\nfor (var i=0; i<5; i++) {\n \ttemp = i;\n\tsetTimeout(function(){\n\t\tconsole.log(temp); \n  \t}, 1000 * (i+1));\n}  \n```\n\n**解决方法**\n\n有几个不同的方式可以拷贝`i`。最普通且常用方法是通过声明函数来建立一个闭包，并将`i`传给此函数。我们这里使用了自调用函数。\n\n```js\nfor (var i=0; i<5; i++) {\n\t(function(num){\n\t\tsetTimeout(function(){\n\t\t\tconsole.log(num); \n\t\t}, 1000 * (i+1)); \n\t})(i);  \n}  \n```\n\n在JavaScript里，参数是按值传递给函数的。像`Number`、`Date`和`String`这些原始类型为基本复制。当你们在一个函数内改变它的值，并不影响外面的作用域。但`Object`类型不一样：如果你在函数内部修改了它的参数，将会影响到所有包含该`Object`的作用域内它的参数。\n\n另一种方法是使用`let`。在ES6中的`let`关键字是可以实现的，它和`var`不一样，因为它支持块作用域的。\n\n```js\nfor (let i=0; i<5; i++) {\n\tvar temp = i;\n \tsetTimeout(function(){\n\t\tconsole.log(i); \n\t}, 1000 * (i+1));\n}  \n```"},"2016-01-30-converting-truthy-falsy-values-to-boolean.md":{"name":"2016-01-30-converting-truthy-falsy-values-to-boolean.md","sha":"4255650c3ee0f1c1954008738123d80592829856","content":"---\nlayout: post\n\ntitle: 将truthy/falsy转换为布尔值\ntip-number: 30\ntip-username: hakhag\ntip-username-profile: https://github.com/hakhag\ntip-tldr: 逻辑运算符是JavaScript的核心之一，在这里你将看到一种无论你传什么值都可以总是得到true或false的方法。\n\n\ncategories:\n    - zh_CN\n---\n\n你可以使用`!!`操作符将[truthy](https://developer.mozilla.org/zh-CN/docs/Glossary/Truthy)或[falsy](https://developer.mozilla.org/zh-CN/docs/Glossary/Falsy)值转换为布尔值。\n\n```js\n!!\"\" // false\n!!0 // false\n!!null // false\n!!undefined // false\n!!NaN // false\n\n!!\"hello\" // true\n!!1 // true\n!!{} // true\n!![] // true\n```\n\n"},"2016-02-02-create-range-0...n-easily-using-one-line.md":{"name":"2016-02-02-create-range-0...n-easily-using-one-line.md","sha":"4e5c5464c3e14d7bb550657cc8ae165956baabc5","content":"---\nlayout: post\n\ntitle: 仅用一行生成0...(N-1)的数列\ntip-number: 33\ntip-username: SarjuHansaliya\ntip-username-profile: https://github.com/SarjuHansaliya\ntip-tldr: 我们可以创建一个函数，它可以仅用一行代码生成0...(N-1)数列。\n\n\ncategories:\n    - zh_CN\n---\n\n使用下面一行代码，我们就可以生成0...(N-1)数列。\n\n### 方法1\n\n```js\nArray.apply(null, {length: N}).map(Number.call, Number);\n```\n\n### 方法2 \n\n```js\n Array.from(new Array(N),(val,index)=>index);\n ```\n\n\n让我们把这一行拆分一下。我们知道`call()`方法在Javascript中的作用。`call()`方法的第一个参数是上下文，从第二个参数开始是调用`call()`方法的函数所需要的参数。\n\n```js\nfunction add(a, b){\n    return (a+b);\n}\nadd.call(null, 5, 6);\n```\n这将返回5加6的和。\n\n数组的`map()`接收两个参数，第一个是`callback`，第二个是`this(上下文)`。回调函数接收三个参数：`value` 、`index`和我们正在迭代的整个数组。所以正常的语法就像：\n\n```js\n[1, 2, 3].map(function(value, index, arr){\n    //Code\n}, this);\n```\n如下一行创建了一个所给长度(length)的数组：\n\n```js\nArray.apply(null, {length: N})\n```\n将各部分合并就成了如下解决方案：\n\n```js\nArray.apply(null, {length: N}).map(Number.call, Number);\n```\n\n如果你需要1...N的数列，你可以这样写：\n\n```js\nArray.apply(null, {length: N}).map(function(value, index){\n  return index+1;  \n});\n```"},"2016-02-11-preventing-unapply-attacks.md":{"name":"2016-02-11-preventing-unapply-attacks.md","sha":"9f95f51064a9e8a0e7b27ed973f9a5d55e960050","content":"---\nlayout: post\n\ntitle: 预防unapply攻击\ntip-number: 42\ntip-username: emars \ntip-username-profile: https://twitter.com/marseltov\ntip-tldr: 冻结内置对象的原型方法。\n\ncategories:\n    - zh_CN\n---\n\n重写内置对象的原型方法，外部代码可以通过重写代码达到暴漏和修改已绑定参数的函数。这在es5的方法下使用`polyfill`时是一个严重的安全问题。\n\n```js\n// bind polyfill 示例\nfunction bind(fn) {\n  var prev = Array.prototype.slice.call(arguments, 1);\n  return function bound() {\n    var curr = Array.prototype.slice.call(arguments, 0);\n    var args = Array.prototype.concat.apply(prev, curr);\n    return fn.apply(null, args);\n  };\n}\n\n\n// unapply攻击\nfunction unapplyAttack() {\n  var concat = Array.prototype.concat;\n  Array.prototype.concat = function replaceAll() {\n    Array.prototype.concat = concat; // restore the correct version\n    var curr = Array.prototype.slice.call(arguments, 0);\n    var result = concat.apply([], curr);\n    return result;\n  };\n}\n```\n\n上面的函数声明忽略了函数bind的`prev`参数，意味着调用`unapplyAttack`之后首次调用`.concat`将会抛出错误。\n\n使用[Object.freeze](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)，可以使对象不可变，你可以防止任何内置对象原型方法被重写。\n\n\n```js\n(function freezePrototypes() {\n  if (typeof Object.freeze !== 'function') {\n    throw new Error('Missing Object.freeze');\n  }\n  Object.freeze(Object.prototype);\n  Object.freeze(Array.prototype);\n  Object.freeze(Function.prototype);\n}());\n```\n\n你可以[在这里](https://glebbahmutov.com/blog/unapply-attack/)阅读更多关于unapply攻击。"},"2016-01-28-curry-vs-partial-application.md":{"name":"2016-01-28-curry-vs-partial-application.md","sha":"2a63166fcbe5b84f6561cd7972db5448db9629b3","content":"---\nlayout: post\n\ntitle: 柯里化(currying)与部分应用(partial application)\ntip-number: 28\ntip-username: bhaskarmelkani\ntip-username-profile: https://www.twitter.com/bhaskarmelkani\ntip-tldr: 柯里化(currying)与部分应用(partial application)是两种将一个函数转换为另一个有着较小普通参数个数的函数的方法。\n\ncategories:\n    - zh_CN\n---\n\n**柯里化(currying)**\n\n柯里化是使一个函数\n\nf: X * Y -> R\n\n转变为\n\nf': X -> (Y -> R)\n\n与用两个参数调用f不同，我们用一个参数运行f'。返回的结果是一个函数，然后用第二个参数调用此函数，得到结果。\n\n如此，如果未柯里化的函数f这样调用\n\nf(3,5)\n\n柯里化后的函数f'是这样调用的\n\nf(3)(5)\n\n比如:\n未柯里化的函数add()\n\n```javascript\n\nfunction add(x, y) {\n  return x + y;\n}\n\nadd(3, 5);   // returns 8\n```\n\n柯里化后的add()\n\n```javascript\nfunction addC(x) {\n  return function (y) {\n    return x + y;\n  }\n}\n\naddC(3)(5);   // returns 8\n```\n\n**柯里化的规则** \n\n柯里化将一个二元函数，转变为一元函数，这个函数将返回另一个一元函数。\n\ncurry: (X × Y → R) → (X → (Y → R))\n\nJavascript Code:\n\n```javascript\nfunction curry(f) {\n  return function(x) {\n    return function(y) {\n      return f(x, y);\n    }\n  }\n}\n```\n\n**部分应用(partial application)**\n\n部分应用将一个函数\n\nf: X * Y -> R\n\n的第一个参数固定而产生一个新的函数\n\nf`: Y -> R\n\nf'与f不同，只需要填写第二个参数，这也是f'比f少一个参数的原因。\n\n比如：将函数add的第一个参数绑定为5来产生函数plus5。\n\n```javascript\nfunction plus5(y) {\n  return 5 + y;\n}\n\nplus5(3);  // returns 8\n```\n\n**部分应用的规则** \n\n部分应用使用一个二元函数和一个值产生了一个一元函数。\n\npartApply : ((X × Y → R) × X) → (Y → R)\n\nJavascript Code:\n\n```javascript\nfunction partApply(f, x) {\n  return function(y) {\n    return f(x, y);\n  }\n}\n```\n"},"2016-02-07-flattening-multidimensional-arrays-in-javascript.md":{"name":"2016-02-07-flattening-multidimensional-arrays-in-javascript.md","sha":"36d7465710d660cfc6095ee133b5a9ca4056ccd8","content":"---\nlayout: post\n\ntitle: Javascript多维数组扁平化\ntip-number: 38\ntip-username: loverajoel\ntip-username-profile: https://www.twitter.com/loverajoel\ntip-tldr: 将多位数组转化为单一数组的三种不同方法。\n\n\ncategories:\n    - zh_CN\n---\n\n下面是将多位数组转化为单一数组的三种不同方法。\n\n对于此数组：\n\n```js\nvar myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];\n```\n\n我们需要的结果是：\n\n```js\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n### 解决方案1：使用[`concat()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/concat)和[`apply()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n\n```js\nvar myNewArray = [].concat.apply([], myArray);\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n### 解决方案2：使用[`reduce()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Flatten_an_array_of_arrays)\n\n```js\nvar myNewArray = myArray.reduce(function(prev, curr) {\n  return prev.concat(curr);\n});\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n### 解决方案3：\n\n```js\nvar myNewArray3 = [];\nfor (var i = 0; i < myArray.length; ++i) {\n  for (var j = 0; j < myArray[i].length; ++j)\n    myNewArray3.push(myArray[i][j]);\n}\nconsole.log(myNewArray3);\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n在[这里](https://jsbin.com/qeqicu/edit?js,console)看一下三种逻辑的实际作用。\n\n对于无限嵌套的数组试一下Underscore的[flatten()](https://github.com/jashkenas/underscore/blob/master/underscore.js#L501).\n\n如果你对性能好奇，[这里](http://jsperf.com/flatten-an-array-loop-vs-reduce/6)有一个测试。"},"2016-02-05-observe-dom-changes.md":{"name":"2016-02-05-observe-dom-changes.md","sha":"17fda5384d886155b4b9165a732a88df3b5e0344","content":"---\nlayout: post\n\ntitle: 扩展插件中观察DOM的变化\ntip-number: 36\ntip-username: beyondns\ntip-username-profile: https://github.com/beyondns\ntip-tldr: 当你为存在的网站开发扩展插件时，由于现代的动态Javascript，操作DOM并不是很容易。\n\n\ncategories:\n    - zh_CN\n---\n[MutationObserver](https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver)是监听DOM变化与当元素变化时做适当操作的一个解决方法。在下面的例子中我们使用计时器模拟了内容的动态加载，第一个元素\"target\"创建后，创建\"subTarget\"。\n在扩展中的代码，`rootObserver`首先开始工作，直到`targetElement`被创建后`rootObserver`停止，然后`elementObserver`开始工作。这个级联观测可以在发现`subTargetElement`时提醒你。\n这个方法在为动态加载内容的网站开发扩展插件时，是很有用的。\n\n```js\nconst observeConfig = {\n    attributes: true,\n    childList: true,\n    characterData: true,\n    subtree: true\n};\n\nfunction initExtension(rootElement, targetSelector, subTargetSelector) {\n    var rootObserver = new MutationObserver(function(mutations) {\n        console.log(\"Inside root observer\");\n        targetElement = rootElement.querySelector(targetSelector);\n        if (targetElement) {\n            rootObserver.disconnect();\n            var elementObserver = new MutationObserver(function(mutations) {\n                console.log(\"Inside element observer\")\n                subTargetElement = targetElement.querySelector(subTargetSelector);\n                if (subTargetElement) {\n                    elementObserver.disconnect();\n                    console.log(\"subTargetElement found!\")\n                }\n            })\n            elementObserver.observe(targetElement, observeConfig);\n        }\n    })\n    rootObserver.observe(rootElement, observeConfig);\n}\n\n(function() {\n\n    initExtension(document.body, \"div.target\", \"div.subtarget\")\n\n    setTimeout(function() {\n        del = document.createElement(\"div\");\n        del.innerHTML = \"<div class='target'>target</div>\"\n        document.body.appendChild(del)\n    }, 3000);\n\n\n    setTimeout(function() {\n        var el = document.body.querySelector('div.target')\n        if (el) {\n            del = document.createElement(\"div\");\n            del.innerHTML = \"<div class='subtarget'>subtarget</div>\"\n            el.appendChild(del)\n        }\n    }, 5000);\n\n})()\n```\n\n"},"2016-02-01-map-to-the-rescue-adding-order-to-object-properties.md":{"name":"2016-02-01-map-to-the-rescue-adding-order-to-object-properties.md","sha":"da22982f3bc77ca396b20f0929946279ba02b5ea","content":"---\nlayout: post\n\ntitle: Map()的营救；使对象属性有顺序\ntip-number: 32\ntip-username: loverajoel\ntip-username-profile: https://twitter.com/loverajoel\ntip-tldr: 对象是一个无序的对象集合。这意味着如果你想在对象里保存有序的数据，你需要重新处理它，因为对象里的数据不保证是有序的。\n\ncategories:\n    - zh_CN\n---\n\n## 对象属性顺序\n\n> 一个对象是一个`Object`类型的实例。它是由一些未排序的元素组成的集合，其中包含了原始变量，对象，和函数。一个对象的属性所对应的函数被称为方法。[ECMAScript](http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf)\n\n实际看一下\n\n```js\nvar myObject = {\n\tz: 1,\n\t'@': 2,\n\tb: 3,\n\t1: 4,\n\t5: 5\n};\nconsole.log(myObject) // Object {1: 4, 5: 5, z: 1, @: 2, b: 3}\n\nfor (item in myObject) {...\n// 1\n// 5\n// z\n// @\n// b\n```\n因为技术实现，每个浏览器在排序时都有自己的规则，顺序是不确定的。\n\n## 怎么解决呢?\n\n### Map\n\n使用ES6的新特性Map。[Map](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Map) 对象以插入的顺序遍历元素。`for...of`循环为每一次循环返回一个[key, value]数组。\n\n```js\nvar myObject = new Map();\nmyObject.set('z', 1);\nmyObject.set('@', 2);\nmyObject.set('b', 3);\nfor (var [key, value] of myObject) {\n  console.log(key, value);\n...\n// z 1\n// @ 2\n// b 3\n```\n\n### 攻克老浏览器\n\nMozilla 建议:\n> 所以，如果过你想在跨浏览器环境中模拟一个有序的关联数组，你要么使用两个分开的数组（一个保存key，另一个保存value）,要么构建一个单属性对象(single-property objects)的数组。\n\n```js\n// 使用分开的数组\nvar objectKeys = [z, @, b, 1, 5];\nfor (item in objectKeys) {\n\tmyObject[item]\n...\n\n// 构建一个单属性对象(single-property objects)的数组\nvar myData = [{z: 1}, {'@': 2}, {b: 3}, {1: 4}, {5: 5}];\n```"},"2016-02-08-advanced-properties.md":{"name":"2016-02-08-advanced-properties.md","sha":"cc19982dd7fed8ad8a8104dda8537237966446bf","content":"---\nlayout: post\n\ntitle: Javascript高级特性\ntip-number: 39\ntip-username: mallowigi\ntip-username-profile: https://github.com/mallowigi\ntip-tldr: 怎样给一个对象添加私有参数、`getter`或`setter`。\n\n\ncategories:\n    - zh_CN\n---\n\n在Javascript里配置对象属性是可以实现的，比如将一个参数设为伪私有或者只读。这个特性从ECMAScript 5.1开始就可以使用了，因此近来的浏览器都是支持的。\n要实现这些功能，你需要使用`Object`的原型方法`defineProperty`，像这样：\n\n```js\nvar a = {};\nObject.defineProperty(a, 'readonly', {\n  value: 15,\n  writable: false\n});\n\na.readonly = 20;\nconsole.log(a.readonly); // 15\n```\n\n语法如下：\n\n```js\nObject.defineProperty(dest, propName, options)\n```\n\n或者定义多个：\n\n```js\nObject.defineProperties(dest, {\n  propA: optionsA,\n  propB: optionsB, //...\n})\n```\n\n`options`包含如下的属性：\n- *value*: 如果参数不是`getter`（请看下文），`value`是必须的。`{a: 12}` === `Object.defineProperty(obj, 'a', {value: 12})`\n- *writable*: 将参数设为只读。需要注意的是如果参数是嵌套对象，它的元素仍是能可修改的。\n- *enumerable*: 将参数设为隐藏。这意味着`for ... of`循环和`stringify`的结果里不会包含这些参数，但是这个参数还是存在的。提示：这并不意味着参数是私有的！他依旧可以从外界访问，只是意味着不会被打印。\n- *configurable*: 将属性设置为不能更改，比如：防止参数被删除或重新定义。如果此对象是一个嵌套对象，他的参数依旧是可配置的。\n\n\n所以如果想创建私有静态变量，你可以这样定义：\n\n```js\nObject.defineProperty(obj, 'myPrivateProp', {value: val, enumerable: false, writable: false, configurable: false});\n```\n\n除了配置属性，由于`defineProperty`第二个参数是字符串，所以允许我们定义*动态变量(defineProperty)*。例如，我们可以说我们要根据一些外部配置创建一个属性：\n\n```js\n\nvar obj = {\n  getTypeFromExternal(): true // illegal in ES5.1\n}\n\nObject.defineProperty(obj, getTypeFromExternal(), {value: true}); // ok\n\n// For the example sake, ES6 introduced a new syntax:\nvar obj = {\n  [getTypeFromExternal()]: true\n}\n```\n\n还没有结束！高级特性允许我们创建**getter**和**setter**，就像其他面向对象(OOP)语言！这种情况下，我们不能使用`writable`、`enumerable`和`configurable`参数，而是：\n\n```js\nfunction Foobar () {\n  var _foo; //  true private property\n\n  Object.defineProperty(obj, 'foo', {\n    get: function () { return _foo; }\n    set: function (value) { _foo = value }\n  });\n\n}\n\nvar foobar = new Foobar();\nfoobar.foo; // 15\nfoobar.foo = 20; // _foo = 20\n```\n\n除了封装与先进的访问器这些明显的优点，你还发现我们并没有“调用”`getter`，而是不需要使用小括号直接“取得”了属性！这太棒了！例如，我们可以想象我们有一个多层嵌套对象，像这样：\n\n```js\nvar obj = {a: {b: {c: [{d: 10}, {d: 20}] } } };\n```\n\n现在我们不需要调用`a.b.c[0].d`（其中某个属性可能是`undefined`且抛出错误），我们可以创建一个别名：\n\n```js\nObject.defineProperty(obj, 'firstD', {\n  get: function () { return a && a.b && a.b.c && a.b.c[0] && a.b.c[0].d }\n})\n\nconsole.log(obj.firstD) // 10\n```\n\n### 提示\n\n如果你定义了`getter`而没有定义`setter`却仍要给它赋值，你将会得到一个错误。这在使用像`$.extend`或`_.merge`这样的辅助方法时是尤为重要的。要小心！\n\n### 链接\n\n- [defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)\n- [Defining properties in JavaScript](http://bdadam.com/blog/defining-properties-in-javascript.html)\n"},"2016-02-15-detect-document-ready-in-pure-js.md":{"name":"2016-02-15-detect-document-ready-in-pure-js.md","sha":"9478b36e8ff0ad789c42d8b229e7831842e87349","content":"---\nlayout: post\n\ntitle: 纯JS监听document是否加载完成\ntip-number: 46\ntip-username: loverajoel\ntip-username-profile: https://www.twitter.com/loverajoel\ntip-tldr: 跨浏览器且纯JavaScript检测document是否加载完成。\n\ncategories:\n    - zh_CN\n---\n\n跨浏览器且纯JavaScript检测document是否加载完成的方法是使用[`readyState`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/readyState).\n\n```js\nif (document.readyState === 'complete') {\n  // 页面已完全加载\n}\n```\n\n这样可以在document完全加载时监测到……\n\n\n```js\nlet stateCheck = setInterval(() => {\n  if (document.readyState === 'complete') {\n\tclearInterval(stateCheck);\n\t// document ready\n  }\n}, 100);\n```\n\n或者使用[onreadystatechange](https://developer.mozilla.org/zh-CN/docs/Web/Events/readystatechange)\n\n\n```js\ndocument.onreadystatechange = () => {\n  if (document.readyState === 'complete') {\n\t// document ready\n  }\n};\n```\n\n使用`document.readyState === 'interactive'`监听DOM是否加载完成。\n"},"2016-02-14-calculate-the-max-min-value-from-an-array.md":{"name":"2016-02-14-calculate-the-max-min-value-from-an-array.md","sha":"230a4c41a8851505590318882b7915f882b2c138","content":"---\nlayout: post\n\ntitle: 计算数组中的最大值/最小值\ntip-number: 45\ntip-username: loverajoel\ntip-username-profile: https://www.twitter.com/loverajoel\ntip-tldr: 对于纯数字数组，使用内置函数Math.max()和Math.min()的方法。\n\ncategories:\n    - zh_CN\n---\n\n内置函数[Math.max()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/max)和[Math.min()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Math/min)可以分别找出参数中的最大值和最小值。\n\n```js\nMath.max(1, 2, 3, 4); // 4\nMath.min(1, 2, 3, 4); // 1\n```\n\n这些函数对于数字组成的数组是不能用的。但是，这有一些类似地方法。\n\n[`Function.prototype.apply()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)让你可以使用提供的`this`与参数组成的_数组(array)_来调用函数。\n\n```js\nvar numbers = [1, 2, 3, 4];\nMath.max.apply(null, numbers) // 4\nMath.min.apply(null, numbers) // 1\n```\n\n给`apply()`第二个参数传递`numbers`数组，等于使用数组中的所有值作为函数的参数。\n\n一个更简单的，基于ES2015的方法来实现此功能，是使用[展开运算符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_operator).\n\n```js\nvar numbers = [1, 2, 3, 4];\nMath.max(...numbers) // 4\nMath.min(...numbers) // 1\n```\n\n此运算符使数组中的值在函数调用的位置展开。\n"},"2016-02-13-know-the-passing-mechanism.md":{"name":"2016-02-13-know-the-passing-mechanism.md","sha":"002abae52a7715f7a5b2e8c6d2e1e2e93913cf84","content":"---\nlayout: post\n\ntitle: 了解传值机制\ntip-number: 44\ntip-username: bmkmanoj\ntip-username-profile: https://github.com/bmkmanoj\ntip-tldr: JavaScript理论上说只传递原始类型和对象（或引用）类型的值。在引用类型的情况下引用值本身通过值传递。\n\ncategories:\n    - zh_CN\n---\n\n理论上，JavaScript通过值传递。它既不是值传递也不是引用传递，具体取决于它的真实场景。要理解传值机制，看一下下面两个实例代码和解释。\n\n### 实例 1\n\n```js\n\nvar me = {\t\t\t\t\t// 1\n\t'partOf' : 'A Team'\n}; \n\nfunction myTeam(me) {\t\t// 2\n\n\tme = {\t\t\t\t\t// 3\n\t\t'belongsTo' : 'A Group'\n\t}; \n} \t\n\nmyTeam(me);\t\t\nconsole.log(me);\t\t\t// 4  : {'partOf' : 'A Team'}\n\n```\n\n在上面的实例里`myTeam`被调用的时候，JavaScript *传递*`me`*对象的引用值，因为它是一个对象*。而且调用本身建立了同一个对象的两个独立的引用，（虽然在这里的的命名都是相同的，比如`me`, 这有些无调行，而且给我们一个这是单个引用的印象）因此，引用变量本身是独立的。\n\n当我们在#`3`定义了一个新的对象，我们完全改变了`myTeam`函数内的引用值，这对此函数作用域外的原始对象是没有任何影响的，外作用域的引用仍保留在原始对象上，因此从#`4`输出去了。 \n\n\n### 实例 2\n\n```js\n\nvar me = {\t\t\t\t\t// 1\n\t'partOf' : 'A Team'\n}; \n\nfunction myGroup(me) { \t\t// 2\n\tme.partOf = 'A Group';  // 3\n} \n\nmyGroup(me);\nconsole.log(me);\t\t\t// 4  : {'partOf' : 'A Group'}\n\t\n```\n\n当`myGroup`调用时，我们将对象`me`传给函数。但是与实例1的情况不同，我们没有指派`me`变量到任何新对象，有效的说明了`myGroup`函数作用域内的对象引用值依旧是原始对象的引用值，而且我们在作用域内修改对象的参数值同样有效的修改了原始对象的参数。因此你得到了#`7`的输出结果。\n\n所以后面的例子是否说明javascript是引用传递呢？不，并没有。请记住，*如果是对象的话，JavaScript将引用按值传递*。这种混乱往往发生在我们没有完全理解什么通过引用传递的情况下。这就是确切的原因，有些人更愿意称它为*call-by-sharing*。\n\n\n*此文最初被作者发表在[js-by-examples](https://github.com/bmkmanoj/js-by-examples/blob/master/examples/js_pass_by_value_or_reference.md)*"},"2016-02-10-array-average-and-median.md":{"name":"2016-02-10-array-average-and-median.md","sha":"6d9903d1221082cb12ce74c0bd8f83d30bff965c","content":"---\nlayout: post\n\ntitle: 数组平均值与中值\ntip-number: 41\ntip-username: soyuka\ntip-username-profile: https://github.com/soyuka\ntip-tldr: 计算数组的平均值与中位数\n\n\ncategories:\n    - zh_CN\n---\n\n下面的例子都基于如下数组：\n\n```javascript\nlet values = [2, 56, 3, 41, 0, 4, 100, 23];\n```\n\n要取得平均值，我们需要将数字求和，然后除以`values`的数目，步骤如下：\n- 取得数组长度(length)\n- 求和(sum)\n- 取得平均值(`sum/length`)\n\n```javascript\nlet values = [2, 56, 3, 41, 0, 4, 100, 23];\nlet sum = values.reduce((previous, current) => current += previous);\nlet avg = sum / values.length;\n// avg = 28\n```\n\n或者：\n\n```javascript\nlet values = [2, 56, 3, 41, 0, 4, 100, 23];\nlet count = values.length;\nvalues = values.reduce((previous, current) => current += previous);\nvalues /= count;\n// avg = 28\n```\n\n取得中值的步骤是：\n- 将数组排序\n- 取得中位数\n\n```javascript\nlet values = [2, 56, 3, 41, 0, 4, 100, 23];\nvalues.sort((a, b) => a - b);\nlet lowMiddle = Math.floor((values.length - 1) / 2);\nlet highMiddle = Math.ceil((values.length - 1) / 2);\nlet median = (values[lowMiddle] + values[highMiddle]) / 2;\n// median = 13,5\n```\n\n或者使用[无符号右移](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Right_shift)操作符：\n\n```javascript\nlet values = [2, 56, 3, 41, 0, 4, 100, 23];\nvalues.sort((a, b) => a - b);\nlet median = (values[(values.length - 1) >> 1] + values[values.length >> 1]) / 2\n// median = 23\n```\n"},"2016-01-29-speed-up-recursive-functions-with-memoization.md":{"name":"2016-01-29-speed-up-recursive-functions-with-memoization.md","sha":"c4860a96a0148332002b776a9afcc0ebd6054566","content":"---\nlayout: post\n\ntitle: 运用存储加速递归 Speed up recursive functions with memoization\ntip-number: 29\ntip-username: hingsir\ntip-username-profile: https://github.com/hingsir\ntip-tldr: 大家对斐波那契(Fibonacci)数列都很熟悉。我们可以再20秒内写出下面这样一个方法，它可以运行，但并不高效。它做了太多重复的运算，我们可以通过存储这些运算结果来使其加速。\n\n\ncategories:\n    - zh_CN\n---\n\n大家对斐波那契(Fibonacci)数列都很熟悉。我们可以再20秒内写出下面这样一个方法。\n\n```js\nvar fibonacci = function(n){\n    return n < 2 ? n : fibonacci(n-1) + fibonacci(n-2);\n}\n```\n它可以运行，但并不高效。它做了太多重复的运算，我们可以通过存储这些运算结果来使其加速。\n\n```js\nvar fibonacci = (function() {\n  var cache = [0, 1]; // cache the value at the n index\n  return function(n) {\n    if (cache[n] === undefined) {\n      for (var i = cache.length; i <= n; ++i) {\n        cache[i] = cache[i-1] + cache[i-2];\n      }\n    }\n    return cache[n];\n  }\n})()\n```\n我们也可以定义一个高阶函数，它接收一个方法作为参数，返回一个该方法运用存储后的新方法。\n\n```js\nvar memoize = function(func){\n    var cache = {};\n    return function(){\n        var key = Array.prototype.slice.call(arguments).toString();\n        return key in cache ? cache[key] : (cache[key] = func.apply(this,arguments));\n    }\n}\nfibonacci = memoize(fibonacci);\n```\n\nES6版本的memoize函数如下：\n\n```js\nvar memoize = function(func){\n    const cache = {};\n    return (...args) => {\n        const key = [...args].toString();\n        return key in cache ? cache[key] : (cache[key] = func(...args));\n    }\n}\nfibonacci = memoize(fibonacci);\n```\n\n我们可以将`memoize()`用在很多其他地方\n\n* GCD(最大公约数)\n\n```js\nvar gcd = memoize(function(a,b){\n    var t;\n    if (a < b) t=b, b=a, a=t;\n    while(b != 0) t=b, b = a%b, a=t;\n    return a;\n})\ngcd(27,183); //=> 3\n```\n* 阶乘运算\n\n```js\nvar factorial = memoize(function(n) {\n    return (n <= 1) ? 1 : n * factorial(n-1);\n})\nfactorial(5); //=> 120\n```\n"},"2016-01-22-two-ways-to-empty-an-array.md":{"name":"2016-01-22-two-ways-to-empty-an-array.md","sha":"f076fff75d2ca328d9359cfe58c7c72ea18529fd","content":"---\nlayout: post\n\ntitle: 清空数组的两种方法\ntip-number: 22\ntip-username: microlv\ntip-username-profile: https://github.com/microlv\ntip-tldr: 在JavaScript中清空一个数组有很多方法，但这是一个最高效的方法。\n\ncategories:\n    - zh_CN\n---\n\n如果你定义了一个数组，然后你想清空它。\n通常，你会这样做：\n\n```javascript\n// 定义一个数组\nvar list = [1, 2, 3, 4];\nfunction empty() {\n    //清空数组\n    list = [];\n}\nempty();\n```\n但是，这有一个效率更高的方法来清空数组。\n你可以这样写:\n```javascript\nvar list = [1, 2, 3, 4];\nfunction empty() {\n    //empty your array\n    list.length = 0;\n}\nempty();\n```\n* `list = []` 将一个新的数组的引用赋值给变量，其他引用并不受影响。\n这意味着以前数组的内容被引用的话将依旧存在于内存中，这将导致内存泄漏。\n\n* `list.length = 0` 删除数组里的所有内容，也将影响到其他引用。\n\n然而，如果你复制了一个数组（A 和 Copy-A），如果你用`list.length = 0`清空了它的内容，复制的数组也会清空它的内容。\n\n考虑一下将会输出什么：\n```js\nvar foo = [1,2,3];\nvar bar = [1,2,3];\nvar foo2 = foo;\nvar bar2 = bar;\nfoo = [];\nbar.length = 0;\nconsole.log(foo, bar, foo2, bar2);\n\n//[] [] [1, 2, 3] []\n```\n更多内容请看Stackoverflow：\n[difference-between-array-length-0-and-array](http://stackoverflow.com/questions/4804235/difference-between-array-length-0-and-array)\n\n"},"2016-01-10-check-if-a-property-is-in-a-object.md":{"name":"2016-01-10-check-if-a-property-is-in-a-object.md","sha":"0e128cc88435dea4014ef26d01b8db3df6d864b9","content":"---\nlayout: post\n\ntitle: 检查某对象是否有某属性\ntip-number: 10\ntip-username: loverajoel\ntip-username-profile: https://www.twitter.com/loverajoel\ntip-tldr: 这是一些检查某对象是否有某属性的方法。\n\ncategories:\n    - zh_CN\n---\n\n当你需要检查某属性是否存在于一个[对象](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_Objects)，你可能会这样做：\n\n```javascript\nvar myObject = {\n  name: '@tips_js'\n};\n\n\nif (myObject.name) { ... }\n\n```\n\n这是可以的，但是你需要知道有两种原生方法可以解决此类问题。[`in` 操作符](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/in) 和 [`Object.hasOwnProperty`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)，任何继承自`Object`的对象都可以使用这两种方法。\n\n### 看一下较大的区别\n\n```javascript\nvar myObject = {\n  name: '@tips_js'\n};\n\nmyObject.hasOwnProperty('name'); // true\n'name' in myObject; // true\n\n\nmyObject.hasOwnProperty('valueOf'); // false, valueOf 继承自原型链\n'valueOf' in myObject; // true\n\n```\n\n\n两者检查属性的深度不同，换言之`hasOwnProperty`只在本身有此属性时返回true,而`in`操作符不区分属性来自于本身或继承自原型链。\n\n这是另一个例子\n\n```javascript\nvar myFunc = function() {\n  this.name = '@tips_js';\n};\nmyFunc.prototype.age = '10 days';\n\nvar user = new myFunc();\n\nuser.hasOwnProperty('name'); // true\n\nuser.hasOwnProperty('age'); // false, 因为age来自于原型链\n```\n\n[在线示例](https://jsbin.com/tecoqa/edit?js,console)!\n\n同样建议阅读关于检查对象是否包含属性时常见错误的[讨论](https://github.com/loverajoel/jstips/issues/62)。\n"},"2016-02-06-deduplicate-an-array.md":{"name":"2016-02-06-deduplicate-an-array.md","sha":"f257d42f1563653d8458dbb35e792448a974b487","content":"---\nlayout: post\n\ntitle: 数组去重\ntip-number: 37\ntip-username: danillouz\ntip-username-profile: https://www.twitter.com/danillouz\ntip-tldr: 移除包含不同类型数据的数组中重复的元素。\n\n\ncategories:\n    - zh_CN\n---\n\n# 原始变量\n如果一个数组只包含原始变量，我们可以使用[`filter`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)和[`indexOf`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)方法将其去重：\n\n```javascript\nvar deduped = [ 1, 1, 'a', 'a' ].filter(function (el, i, arr) {\n\treturn arr.indexOf(el) === i;\n});\n\nconsole.log(deduped); // [ 1, 'a' ]\n```\n\n## ES2015\n我们可以使用[箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)使写法更简明：\n\n```javascript\nvar deduped = [ 1, 1, 'a', 'a' ].filter( (el, i, arr) => arr.indexOf(el) === i);\n\nconsole.log(deduped); // [ 1, 'a' ]\n```\n\n但是根据[Sets](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)和[`from`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)方法的介绍，我们可以更简明的实现。\n\n```javascript\nvar deduped = Array.from( new Set([ 1, 1, 'a', 'a' ]) );\n\nconsole.log(deduped); // [ 1, 'a' ]\n```\n\n# Objects\n当元素为对象(Object)时，我们就不能用这种办法了，\n因为对象存储的是引用而原始变量存储的是值。\n\n```javascript\n1 === 1 // true\n\n'a' === 'a' // true\n\n{ a: 1 } === { a: 1 } // false\n```\n\n因此我们需要改变一下我们的实现方法，使用哈希表。\n\n```javascript\nfunction dedup(arr) {\n\tvar hashTable = {};\n\n\treturn arr.filter(function (el) {\n\t\tvar key = JSON.stringify(el);\n\t\tvar match = Boolean(hashTable[key]);\n\n\t\treturn (match ? false : hashTable[key] = true);\n\t});\n}\n\nvar deduped = dedup([\n\t{ a: 1 },\n\t{ a: 1 },\n\t[ 1, 2 ],\n\t[ 1, 2 ]\n]);\n\nconsole.log(deduped); // [ {a: 1}, [1, 2] ]\n```\n\n因为哈希表在Javascript里是一个简单的`Object`，它的`key`永远是`String`类型。这意味着我们不能区分字符串和数字表示的相同的值，如`1`和`'1'`。\n\n```javascript\nvar hashTable = {};\n\nhashTable[1] = true;\nhashTable['1'] = true;\n\nconsole.log(hashTable); // { '1': true }\n```\n\n然而，因为我们使用的[`JSON.stringify`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)，`String`类型的`key`\n将会被存储为一个字符串值，这样`hashTable`的`key`就唯一了。\n\n```javascript\nvar hashTable = {};\n\nhashTable[JSON.stringify(1)] = true;\nhashTable[JSON.stringify('1')] = true;\n\nconsole.log(hashTable); // { '1': true, '\\'1\\'': true }\n```\n\n这意味着相同的值，但不同类型的元素，将以原来的格式保留。\n\n```javascript\nvar deduped = dedup([\n\t{ a: 1 },\n\t{ a: 1 },\n\t[ 1, 2 ],\n\t[ 1, 2 ],\n\t1,\n\t1,\n\t'1',\n\t'1'\n]);\n\nconsole.log(deduped); // [ {a: 1}, [1, 2], 1, '1' ]\n```\n\n# 阅读材料\n## 函数\n* [`filter`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n* [`indexOf`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n* [`from`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from)\n* [`JSON.stringify`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n\n## ES2015\n* [箭头函数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n* [Set](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Set)\n\n## Stack overflow\n* [remove duplicates from array](http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array/9229821#9229821)\n"},"2016-02-09-using-json-stringify.md":{"name":"2016-02-09-using-json-stringify.md","sha":"28f0f8cec9d534b660ba178bd44f63a4131ed71e","content":"---\nlayout: post\n\ntitle: 使用JSON.Stringify\ntip-number: 40\ntip-username: vamshisuram\ntip-username-profile: https://github.com/vamshisuram\ntip-tldr: 将JSON对象的参数选择性地生成字符串。\n\n\ncategories:\n    - zh_CN\n---\n\n加入有一个对象具有参数\"prop1\", \"prop2\", \"prop3\"。\n我们可以通过传递 __附加参数__ 给 __JSON.stringify__ 来选择性将参数生成字符串，像这样：\n\n```javascript\nvar obj = {\n    'prop1': 'value1',\n    'prop2': 'value2',\n    'prop3': 'value3'\n};\n\nvar selectedProperties = ['prop1', 'prop2'];\n\nvar str = JSON.stringify(obj, selectedProperties);\n\n// str\n// {\"prop1\":\"value1\",\"prop2\":\"value2\"}\n\n```\n\n __\"str\"__ 降至包含选择的参数。\n\n除了传递数组，我们也可以传递函数。\n\n```javascript\n\nfunction selectedProperties(key, val) {\n    // the first val will be the entire object, key is empty string\n    if (!key) {\n        return val;\n    }\n\n    if (key === 'prop1' || key === 'prop2') {\n        return val;\n    }\n\n    return;\n}\n```\n\n最后一个参数，可以修改生成字符串的方式。\n\n```javascript\nvar str = JSON.stringify(obj, selectedProperties, '\\t\\t');\n\n/* str output with double tabs in every line.\n{\n        \"prop1\": \"value1\",\n        \"prop2\": \"value2\"\n}\n*/\n\n```\n\n"},"2016-02-16-basics-declarations.md":{"name":"2016-02-16-basics-declarations.md","sha":"c29d36765223dcd3627e886e62c6ca47c2d53be2","content":"---\nlayout: post\n\ntitle: 变量声明\ntip-number: 47\ntip-username: adaniloff \ntip-username-profile: https://github.com/adaniloff\ntip-tldr: 理解并应用变量的声明。\n\ncategories:\n    - zh_CN\n---\n\n下文是JavaScript中声明变量的不同方法。 \n注释与`console.log`足够说明这里发生了什么：\n\n```js\nvar y, x = y = 1 //== var x; var y; x = y = 1\nconsole.log('--> 1:', `x = ${x}, y = ${y}`)\n\n// 将会输出\n//--> 1: x = 1, y = 1\n```\n\n首先，我们只设置了两个变量。并没有很多。\n\n```js\n;(() => { \n  var x = y = 2 // == var x; y = 2;\n  console.log('2.0:', `x = ${x}, y = ${y}`)\n})()\nconsole.log('--> 2.1:', `x = ${x}, y = ${y}`)\n\n// 将会输出\n//2.0: x = 2, y = 2\n//--> 2.1: x = 1, y = 2\n```\n\n正如你所看到的，代码只改变了全局的`y`，因为我们在闭包里并没有声明此变量。\n\n```js\n;(() => { \n  var x, y = 3 // == var x; var y = 3;\n  console.log('3.0:', `x = ${x}, y = ${y}`)\n})()\nconsole.log('--> 3.1:', `x = ${x}, y = ${y}`)\n\n// 将会输出\n//3.0: x = undefined, y = 3\n//--> 3.1: x = 1, y = 2\n```\n\n现在我们用`var`声明了两个变量。意味着他们仅在闭包内有作用。\n\n```js\n;(() => { \n  var y, x = y = 4 // == var x; var y; x = y = 4\n  console.log('4.0:', `x = ${x}, y = ${y}`)\n})()\nconsole.log('--> 4.1:', `x = ${x}, y = ${y}`)\n\n// 将会输出\n//4.0: x = 4, y = 4\n//--> 4.1: x = 1, y = 2\n```\n\n两个变量都使用`var`声明了而且在之后又给它们赋值。由于`local > global`，闭包内声明了`x`和`y`，意味着闭包内是无法访问全局的`x`和`y`的。\n\n```js\nx = 5 // == x = 5\nconsole.log('--> 5:', `x = ${x}, y = ${y}`)\n\n// 将会输出\n//--> 5: x = 5, y = 2\n```\n\n最后一行的结果是很明显的。\n\n你可以在这里测试并看到结果 [感谢babel](https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=var%20y%2C%20x%20%3D%20y%20%3D%201%20%2F%2F%3D%3D%20var%20x%3B%20var%20y%3B%20x%20%3D%20y%20%3D%201%0Aconsole.log('--%3E%201%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%0A%2F%2F%20Will%20print%0A%2F%2F--%3E%201%3A%20x%20%3D%201%2C%20y%20%3D%201%0A%0A%3B(()%20%3D%3E%20%7B%20%0A%20%20var%20x%20%3D%20y%20%3D%202%20%2F%2F%20%3D%3D%20var%20x%3B%20y%20%3D%202%3B%0A%20%20console.log('2.0%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%7D)()%0Aconsole.log('--%3E%202.1%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%0A%2F%2F%20Will%20print%0A%2F%2F2.0%3A%20x%20%3D%202%2C%20y%20%3D%202%0A%2F%2F--%3E%202.1%3A%20x%20%3D%201%2C%20y%20%3D%202%0A%0A%3B(()%20%3D%3E%20%7B%20%0A%20%20var%20x%2C%20y%20%3D%203%20%2F%2F%20%3D%3D%20var%20x%3B%20var%20y%20%3D%203%3B%0A%20%20console.log('3.0%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%7D)()%0Aconsole.log('--%3E%203.1%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%0A%2F%2F%20Will%20print%0A%2F%2F3.0%3A%20x%20%3D%20undefined%2C%20y%20%3D%203%0A%2F%2F--%3E%203.1%3A%20x%20%3D%201%2C%20y%20%3D%202%0A%0A%3B(()%20%3D%3E%20%7B%20%0A%20%20var%20y%2C%20x%20%3D%20y%20%3D%204%20%2F%2F%20%3D%3D%20var%20x%3B%20var%20y%3B%20x%20%3D%20y%20%3D%203%0A%20%20console.log('4.0%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%7D)()%0Aconsole.log('--%3E%204.1%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%0A%2F%2F%20Will%20print%0A%2F%2F4.0%3A%20x%20%3D%204%2C%20y%20%3D%204%0A%2F%2F--%3E%204.1%3A%20x%20%3D%201%2C%20y%20%3D%202%0A%0Ax%20%3D%205%20%2F%2F%20%3D%3D%20x%20%3D%205%0Aconsole.log('--%3E%205%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%0A%2F%2F%20Will%20print%0A%2F%2F--%3E%205%3A%20x%20%3D%205%2C%20y%20%3D%202).\n\n更多相关内容请看[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var).\n\n特别感谢@kurtextrem的合作 :)!\n"},"2016-02-17-reminders-about-reduce-function-usage.md":{"name":"2016-02-17-reminders-about-reduce-function-usage.md","sha":"765b63ec470b03a69e54f56ef0ea8d532326add1","content":"---\nlayout: post\n\ntitle: 怎样`reduce()`数组\ntip-number: 48\ntip-username: darul75\ntip-username-profile: https://twitter.com/darul75\ntip-tldr: 使用`reduce()`函数时的一些建议\n\ncategories:\n    - zh_CN\n---\n\n文档里说`reduce()`方法接收一个函数作为累加器（accumulator），数组中的每个值（从左到右）开始合并，最终为一个值。\n\n### `reduce()`\n\n[reduce()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) 函数接收2个参数(M: 必填, O: 可选)：\n\n- (M) 回调**reducer 函数** 处理先前的结算结果和下一个元素直到序列结束。\n- (O) **初值** 作为第一次调用回调时的第一个参数。\n\n所以，让我们先看一个普通用法，之后再看一个复杂用法。\n\n### 普通用法 (累加，关联)\n\n我们正在逛亚马逊(单价为美元$) 我们的购物车实在太满了，我们来计算一下总价吧：\n\n```javascript\n// 当前的购物清单\nvar items = [{price: 10}, {price: 120}, {price: 1000}];\n\n// reducer函数\nvar reducer = function add(sumSoFar, nextPrice) { return sumSoFar + nextPrice.price; };\n\n// 开始运行\nvar total = items.reduce(reducer, 0);\n\nconsole.log(total); // 1130\n```\n\n`reduce`函数可选的参数在第一个例子里是基本变量数字0，但是它也可以是一个对象，数组... 而不仅是基本类型，之后我们将会看到。\n\n现在，我们收到一个20$的优惠券。\n\n```javascript\nvar total = items.reduce(reducer,-20);\n\nconsole.log(total); // 1110\n```\n\n### 进阶用法(结合)\n\n第二种用法的例子是`Redux`的[combineReducers](http://redux.js.org/docs/api/combineReducers.html)函数[源码](https://github.com/reactjs/redux/blob/master/src/combineReducers.js#L93)里用到的。\n\n此创意是将`reducer`函数拆分为独立的函数，最后组合成一个新的*单一的大`reducer`函数*。 \n\n为了说明，我们创建一个单一的对象，包含一些可以计算不同货币($, €...)的总价值的`reducer`函数。\n\n```javascript\nvar reducers = {\n  totalInDollar: function(state, item) {\n    state.dollars += item.price;\n    return state;\n  },\n  totalInEuros : function(state, item) {\n    state.euros += item.price * 0.897424392;\n    return state;\n  },\n  totalInPounds : function(state, item) {\n    state.pounds += item.price * 0.692688671;\n    return state;\n  },\n  totalInYen : function(state, item) {\n    state.yens += item.price * 113.852;\n    return state;\n  }\n  // more...\n};\n```\n\n然后我们建立一个瑞士军刀函数 \n\n- 能够调用每一部分的`reduce`函数\n- 返回一个新的`reducer`回调函数\n\n```javascript\nvar combineTotalPriceReducers = function(reducers) {\n  return function(state, item) {\n    return Object.keys(reducers).reduce(\n      function(nextState, key) {\n        reducers[key](state, item);\n        return state;\n      },\n      {}      \n    );\n  }\n};\n```\n\n现在，我们来看一下如何使用它。\n\n```javascript\nvar bigTotalPriceReducer = combineTotalPriceReducers(reducers);\n\nvar initialState = {dollars: 0, euros:0, yens: 0, pounds: 0};\n\nvar totals = items.reduce(bigTotalPriceReducer, initialState);\n\nconsole.log(totals);\n\n/*\nObject {dollars: 1130, euros: 1015.11531904, yens: 127524.24, pounds: 785.81131152}\n*/\n```\n\n我希望这种方法可以使你在自己的需求内使用`reduce()`函数时有新的想法。\n\n使用`reduce`函数也可以实现保存每一次计算结果的功能。这在`Ramdajs`里的[scan](http://ramdajs.com/docs/#scan)函数已经实现了。\n\n[在JSFiddle里运行](https://jsfiddle.net/darul75/81tgt0cd/)\n"},"2016-01-27-short-circuit-evaluation-in-js.md":{"name":"2016-01-27-short-circuit-evaluation-in-js.md","sha":"1743f9254fe64b0f5fed9a73707ab74879fe3f6c","content":"---\nlayout: post\n\ntitle: JS中的短路求值\ntip-number: 27\ntip-username: bhaskarmelkani\ntip-username-profile: https://www.twitter.com/bhaskarmelkani\ntip-tldr: 短路求值是说, 只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值：当AND(`&&`)的第一个运算数的值为false时，其结果必定为false；当OR(`||`)的第一个运算数为true时，最后结果必定为true。\n\ncategories:\n    - zh_CN\n---\n\n[短路求值](https://zh.wikipedia.org/wiki/%E7%9F%AD%E8%B7%AF%E6%B1%82%E5%80%BC)是说, 只有当第一个运算数的值无法确定逻辑运算的结果时，才对第二个运算数进行求值：当AND(`&&`)的第一个运算数的值为false时，其结果必定为false；当OR(`||`)的第一个运算数为true时，最后结果必定为true。\n\n对于下面的`test`条件和`isTrue`与`isFalse`方法\n\n```js\nvar test = true;\nvar isTrue = function(){\n  console.log('Test is true.');\n};\nvar isFalse = function(){\n  console.log('Test is false.');\n};\n\n```\n使用逻辑与 - `&&`.\n\n```js\n// 普通的if语句\nif(test){\n  isTrue();    // Test is true\n}\n\n// 上面的语句可以使用 '&&' 写为：\n\n( test && isTrue() );  // Test is true\n```\n使用逻辑或 - `||`.\n\n```js\ntest = false;\nif(!test){\n  isFalse();    // Test is false.\n}\n\n( test || isFalse());  // Test is false.\n```\n逻辑或可以用来给参数设置默认值。\n\n```js\nfunction theSameOldFoo(name){\n    name = name || 'Bar' ;\n    console.log(\"My best friend's name is \" + name);\n}\ntheSameOldFoo();  // My best friend's name is Bar\ntheSameOldFoo('Bhaskar');  // My best friend's name is Bhaskar\n```\n逻辑与可以用来避免调用undefined参数的属性时报错\n例如:-\n\n```js\nvar dog = {\n  bark: function(){\n     console.log('Woof Woof');\n   }\n};\n\n// 调用 dog.bark();\ndog.bark(); // Woof Woof.\n\n// 但是当dog未定义时，dog.bark() 将会抛出\"Cannot read property 'bark' of undefined.\" 错误\n// 防止这种情况，我们可以使用 &&.\n\ndog&&dog.bark();   // This will only call dog.bark(), if dog is defined.\n\n```\n"},"2016-02-26-extract-unix-timestamp-easily.md":{"name":"2016-02-26-extract-unix-timestamp-easily.md","sha":"8782ff03ab80c7f41fb3dab6909de99fb1461f15","content":"---\nlayout: post\n\ntitle: 简单获取unix时间戳\ntip-number: 49\ntip-username: nmrony\ntip-username-profile: https://github.com/nmrony\ntip-tldr: 在Javascript里，你可以简单的取得unix时间戳\n\ncategories:\n    - zh_CN\n---\n\n我们经常需要使用unix时间戳计算。有很多方法可以取得unix时间戳。目前取得unix时间戳最简单最快的方法是：\n\n```js\nconst timestamp = Date.now();\n```\n或\n\n```js\nconst timestamp = new Date().getTime();\n```\n\n要取得一个具体时间的unix时间戳，将`yyyy-mm-dd`作为参数传递给`Date`构造函数。例如\n\n```js\nconst timestamp = new Date('2012-06-08').getTime()\n```\n你还可以像下面一样，在声明`Date`对象的时候添加一个`+`号\n\n```js\nconst timestamp = +new Date()\n```\n或者对于具体时间\n\n```js\nconst timestamp = +new Date('2012-06-08')\n```\n在底层，运行时调用了`Date`对象的`valueOf`方法。然后一元操作符`+`调用了之前返回值的`toNumber()`方法。想要了解更多内容请参考下面链接\n\n* [Date.prototype.valueOf](http://es5.github.io/#x15.9.5.8)\n* [Unary + operator](http://es5.github.io/#x11.4.6)\n* [toNumber()](http://es5.github.io/#x9.3)\n"}}