{"2016-02-26-extract-unix-timestamp-easily.md":{"name":"2016-02-26-extract-unix-timestamp-easily.md","sha":"1488a21379a0211701ac67ecb7ba2560bd075e59","content":"---\nlayout: post\n\ntitle: 在 JavaScript 簡單取得 unix timestamp\ntip-number: 49\ntip-username: nmrony\ntip-username-profile: https://github.com/nmrony\ntip-tldr: 在 JavaScript 你可以簡單取得 unix timestamp\n\ncategories:\n    - zh_TW\n---\n\n我們經常需要計算 unix 的 timestamp。有許多方式可以取得 timestamp。目前取得 unix timestamp 最簡單和快速的方式是：\n\n```js\nconst timestamp = Date.now();\n```\nor\n\n```js\nconst timestamp = new Date().getTime();\n```\n\n如果要取得特定的 unix timestamp 傳送一個 `yyyy-mm--dd` 參數到 `Date` 的建構子。例如：\n\n```js\nconst timestamp = new Date('2012-06-08').getTime()\n```\n\n當你宣告一個 `Date` 物件，也可以加上 `+` 符號：\n\n```js\nconst timestamp = +new Date()\n```\n或指定日期\n\n```js\nconst timestamp = +new Date('2012-06-08')\n```\n在執行時呼叫了 `Date` 物件的 `valueOf` 方法。`+` 運算子呼叫了 `toNumber()` 和回傳的值。更多細節的說明請參考以下的連結。\n\n* [Date.prototype.valueOf](http://es5.github.io/#x15.9.5.8)\n* [Unary + operator](http://es5.github.io/#x11.4.6)\n* [toNumber()](http://es5.github.io/#x9.3)\n"},"2016-01-24-use_===_instead_of_==.md":{"name":"2016-01-24-use_===_instead_of_==.md","sha":"3162e9fe9a5de6f8321be0c08313b4b20d2c2051","content":"---\nlayout: post\n\ntitle: 使用 === 來替代 ==\ntip-number: 24\ntip-username: bhaskarmelkani\ntip-username-profile: https://www.twitter.com/bhaskarmelkani\ntip-tldr: ==（或 !=）運算子如果在執行上需要的話，會自動將類型轉換。 `===`（或 `!==`）運算子則不會執行轉換。`===`（或 `!==`）用來比較數值和類型，相較於 `==` 更來的快速。\n\ncategories:\n    - zh_TW\n---\n\n`==`（或 `!=`）運算子如果在執行上需要的話，會自動將類型轉換。 `===`（或 `!==`）運算子則不會執行轉換。`===`（或 `!==`）用來比較數值和類型，相較於 `==` 更來的快速。（[jsPref](http://jsperf.com/strictcompare)）\n\n```js\n[10] ==  10      // is true\n[10] === 10      // is false\n\n'10' ==  10      // is true\n'10' === 10      // is false\n\n []  ==  0       // is true\n []  === 0       // is false\n\n ''  ==  false   // is true but true == \"a\" is false\n ''  === false   // is false\n\n```\n"},"2016-01-18-rounding-the-fast-way.md":{"name":"2016-01-18-rounding-the-fast-way.md","sha":"4b94a504b63b2cd5150c2dd85af6be3d3453086b","content":"---\nlayout: post\n\ntitle: Truncating 最快的方式（含有風險）\ntip-number: 18\ntip-username: pklinger\ntip-username-profile: https://github.com/pklinger\ntip-tldr: 通常 `~~X` 速度比 `Math.trunc(X)` 快，但是會造成你的程式碼變得很混亂。\n\ncategories:\n    - zh_TW\n---\n\n今天的 tip 是關於性能的部分。\n\n[曾經使用過雙波浪](http://stackoverflow.com/questions/5971645/what-is-the-double-tilde-operator-in-javascript) `~~` 運算符嗎？有時候也被稱為 雙 NOT 位元運算符。你可以使用它來替代 `Math.trunc()` 更為快速。這是為什麼呢？\n\n位元移位運算符 `~` 將輸入的 32 位元轉換成 `-(input + 1)`。因此，雙位元移位運算成為更好的工具，將輸入轉換成 `-(-(input + 1) + 1)` 更趨近 0。對於數字輸入，它類似 `Math.trunc()`。若失敗的話，則回傳 `0`，這或許是解決 `Math.trunc()` 失敗時回傳 `NaN` 的替代方法。\n\n```js\n// 單 ~\nconsole.log(~1337)    // -1338\n\n// 數字輸入\nconsole.log(~~47.11)  // -> 47\nconsole.log(~~1.9999) // -> 1\nconsole.log(~~3)      // -> 3\n```\n\n雖然 ~~ 可以讓性能更好，但是為了增加程式碼可讀性，請使用 Math.trunc()。如果要了解為什麼，這裡有一些關於 `~~` 運算子的分析。\n\n### 適用情況\n\n##### 每個 CPU 的週期次數\n`~~` 整體來說或許比 `Math.trunc()` 來的快，這種[測試的假設](https://jsperf.com/jsfvsbitnot/10)在哪個平台下是很重要的。此外，你通常必須執行數以百萬計的這種操作才可以看到明顯的影響。\n\n##### 當程式碼的清晰度不是這麼重要時\n如果你想要 confuse 他人，或者從你的 minifier/uglifier 取得最大的效用，這是一個相對廉價的方式。\n\n### 禁止的情況\n\n##### 當你的程式碼需要維護時\n\n程式碼的清晰是一直以來都是相當重要的，無論你是不是和一個團隊一起工作，或是對公開的 repo 做 contribute。正如[俗話常說的](http://c2.com/cgi/wiki?CodeForTheMaintainer)：\n> Always code as if the person who ends up maintaining your code is a violent psychopath who knows where you live.\n\n##### 當你忘記 `~~` 總是趨近於零時\n或許新手開發者更關注在 `~~` 優秀之處，卻忘記了「只去掉小數點」的重要性。當我們將浮點數轉換成陣列索引，或是相關順序值，這容易導致 **fencepost 錯誤**（a.k.a 「off-by-one」），實際上可能需要不同類型的分數做四捨五入（程式碼缺乏清晰度很容易造成這個問題。）\n\n舉個例子，如果你基於在「最靠近整數」的數字上做計算，你應該使用 `Math.round()` 而不是 `~~`，但因為開發者的懶惰往往勝過於冰冷的邏輯，而導致不正確的結果。\n\n相反的，許多名稱類似 `Math.xyz()` 的函式反而清楚表達他們的功用，減少了錯誤的可能性。\n\n##### 當處理大量的位元數時\n因為 `~` 首先是進行 32 位元的轉換，`~~` 範圍值的結果在 &plusmn;2.15 億位元左右。如果你沒有明確的檢查你的輸入範圍，當轉換後的值和原始值有很大的差距時，使用者可能會觸發 unexpected 的行為：\n\n```js\na = 2147483647.123  // 最大 32 位正整數，再多一點\nconsole.log(~~a)    // ->  2147483647     (ok)\na += 10000          // ->  2147493647.123 (ok)\nconsole.log(~~a)    // -> -2147483648     (huh?)\n```\n一個容易出現問題的地方是在處理 Unix 時間戳記的地方（以秒為單位，從 1970 年 1 月 1 日 00:00:00 UTC）。一個快速取得這個值的方式是：\n\n```js\nepoch_int = ~~(+new Date() / 1000)  // Date() 以毫秒為單位\n```\n然而，當我們處理在 2038 年 1 月 19 03:14:07 UTC（有時候稱為 **Y2038 limit**）之後的時間戳記，發生可怕的事：\n\n```js\n// 2040 年 1 月 1 日 00:00:00.123 UTC 的時間戳記\nepoch = +new Date('2040-01-01') / 1000 + 0.123      // ->  2208988800.123\n\n// 回到未來！\nepoch_int = ~~epoch                                 // -> -2085978496\nconsole.log(new Date(epoch_int * 1000))             // ->  Wed Nov 25 1903 17:31:44 UTC\n\n// 這很有趣，讓我們取得正確的答案\nepoch_flr = Math.floor(epoch)                       // ->  2208988800\nconsole.log(new Date(epoch_flr * 1000))             // ->  Sun Jan 01 2040 00:00:00 UTC\n```\n\n##### 當原始輸入值沒經過處理\n因為 `~~` 將每個非數字轉換成 `0`：\n\n```js\nconsole.log(~~[])   // -> 0\nconsole.log(~~NaN)  // -> 0\nconsole.log(~~null) // -> 0\n```\n有些開發者把它作為替代輸入驗證。然而，這可能會導致奇怪的邏輯錯誤，你沒辦法區別他們之間誰是無效的輸入，或者是 `0`。因此這_不是_推薦的做法。\n\n##### 當許多人認為 `~~X == Math.floor(X)` 時\n\n許多人因為錯誤的原因以為「雙位元 NOT」等同於 `Math.floor()`。如果你沒辦法準確的使用它，最終你可能會濫用它。\n有些人很細心地提到 `Math.floor()` 是用在正數輸入，而 `Math.ceil()` 是用在負數輸入。但是，這又會強制讓你停下並思考關於你該如何處理數值。這違背了使用 `~~` 做為方便無害的目的。\n\n### 結論\n避免在可能的情況。否則請謹慎使用。\n\n### 管理\n1. 謹慎使用。\n2. 在應用前請先處理數值。\n3. 仔細記錄關於數值被轉換的相關假設。\n4. 至少檢查程式碼並處理：\n   * 不正確輸入反而傳送給其他程式碼模組作為有效的 `0` 的邏輯 Bug。\n   * 在轉換輸入的範圍錯誤。\n   * 因為不正確的四捨五入方向，造成 fencepost 錯誤。\n"},"2016-02-10-array-average-and-median.md":{"name":"2016-02-10-array-average-and-median.md","sha":"488def208f0b8300d22fbd222d882053489bf33f","content":"---\nlayout: post\n\ntitle: 陣列平均值和中間值\ntip-number: 41\ntip-username: soyuka\ntip-username-profile: https://github.com/soyuka\ntip-tldr: 計算陣列的平均值和中間值。\n\n\ncategories:\n    - zh_TW\n---\n\n以下範例基於一個陣列：\n\n```javascript\nlet values = [2, 56, 3, 41, 0, 4, 100, 23];\n```\n\n如果要取得平均，我們必須加總所有數字和再除以數字的個數。步驟是：\n- 取得陣列長度\n- 加總數值\n- 取得平均（`數值總和 / 陣列長度`）\n\n```javascript\nlet values = [2, 56, 3, 41, 0, 4, 100, 23];\nlet sum = values.reduce((previous, current) => current += previous);\nlet avg = sum / values.length;\n// avg = 28\n```\n\n或：\n\n```javascript\nlet values = [2, 56, 3, 41, 0, 4, 100, 23];\nlet count = values.length;\nvalues = values.reduce((previous, current) => current += previous);\nvalues /= count;\n// avg = 28\n```\n\n現在，如果要取得中間值的步驟：\n- 將陣列排序\n- 取得中間值的算術平均值\n\n```javascript\nlet values = [2, 56, 3, 41, 0, 4, 100, 23];\nvalues.sort((a, b) => a - b);\nlet lowMiddle = Math.floor((values.length - 1) / 2);\nlet highMiddle = Math.ceil((values.length - 1) / 2);\nlet median = (values[lowMiddle] + values[highMiddle]) / 2;\n// median = 13,5\n```\n\n隨著位元運算符：\n\n```javascript\nlet values = [2, 56, 3, 41, 0, 4, 100, 23];\nvalues.sort((a, b) => a - b);\nlet median = (values[(values.length - 1) >> 1] + values[values.length >> 1]) / 2\n// median = 13,5\n```\n"},"2016-01-30-converting-truthy-falsy-values-to-boolean.md":{"name":"2016-01-30-converting-truthy-falsy-values-to-boolean.md","sha":"fd60a73913d137d3eeb5185d8d6b2302772463ff","content":"---\nlayout: post\n\ntitle: 將 truthy 和 falsy 轉換成布林值\ntip-number: 30\ntip-username: hakhag\ntip-username-profile: https://github.com/hakhag\ntip-tldr: 邏輯運算子是 JavaScript 核心之一 ，在這裡你可以發現這個方式，不管你給他什麼值，都會得到 true 或 false 。\n\n\ncategories:\n    - zh_TW\n---\n\n你可以使用 `!!` 運算子將 [truthy](https://developer.mozilla.org/en-US/docs/Glossary/Truthy) 或 [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy) 轉換成布林值。\n\n```js\n!!\"\" // false\n!!0 // false\n!!null // false\n!!undefined // false\n!!NaN // false\n\n!!\"hello\" // true\n!!1 // true\n!!{} // true\n!![] // true\n```\n"},"2016-01-17-nodejs-run-a-module-if-it-is-not-required.md":{"name":"2016-01-17-nodejs-run-a-module-if-it-is-not-required.md","sha":"0cc65cb5dd051fd45636125503eb2eb1c0a570c0","content":"---\nlayout: post\n\ntitle: Node.js - 執行尚未被 required 的模組\ntip-number: 17\ntip-username: odsdq\ntip-username-profile: https://twitter.com/odsdq\ntip-tldr: 在 nodejs，你可以讓你的程式取決於 `require('./something.js')` 或 `node something.js` 這兩種不同的方式來執行你的程式碼。如果你想要將你的獨立模組交互使用是非常有用的。\n\ncategories:\n    - zh_TW\n---\n\n在 nodejs，你可以讓你的程式取決於 `require('./something.js')` 或 `node something.js` 這兩種不同的方式來執行你的程式碼。如果你想要將你的獨立模組交互使用是非常有用的。\n\n```js\nif (!module.parent) {\n    // 透過 `node something.js` 執行\n    app.listen(8088, function() {\n        console.log('app listening on port 8088');\n    })\n} else {\n    // 使用 `require('/.something.js')` 方法\n    module.exports = app;\n}\n```\n\n更多資訊請參考 [nodejs modules 官方文件](https://nodejs.org/api/modules.html#modules_module_parent)。\n"},"2016-02-14-calculate-the-max-min-value-from-an-array.md":{"name":"2016-02-14-calculate-the-max-min-value-from-an-array.md","sha":"63ce9b1626ef6d1fef642b48b93e43808f938442","content":"---\nlayout: post\n\ntitle: 從陣列計算最大和最小值\ntip-number: 45\ntip-username: loverajoel\ntip-username-profile: https://www.twitter.com/loverajoel\ntip-tldr: 在數字陣列使用內建的 Max.max() 和 Max.min() 函式的方式。\n\ncategories:\n    - zh_TW\n---\n\n內建函式 [Math.max()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/max) 和 [Math.min()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/min) 分別可以從參數中找到最大值和最小值。\n\n```js\nMath.max(1, 2, 3, 4); // 4\nMath.min(1, 2, 3, 4); // 1\n```\n\n這些函式對於數字陣列是無法作用的。然而，這裡有些解決辦法。\n\n[`Function.prototype.apply()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) 允許你呼叫函式並給定一個 `this` 和一個_陣列_的參數。\n\n```js\nvar numbers = [1, 2, 3, 4];\nMath.max.apply(null, numbers) // 4\nMath.min.apply(null, numbers) // 1\n```\n\n傳送 `numbers` 陣列當作 `apply()` 的第二個參數，函式會呼叫陣列內所有的值當作函式的參數。\n\n更簡單的方式，透過 ES2015 的[展開運算子](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator)來完成。\n\n```js\nvar numbers = [1, 2, 3, 4];\nMath.max(...numbers) // 4\nMath.min(...numbers) // 1\n```\n\n這個運算子可以在函式的參數中把陣列內的數值「展開」。\n"},"2016-01-11-hoisting.md":{"name":"2016-01-11-hoisting.md","sha":"13c1c033af4390f089fce8221f873ec2e59f9565","content":"---\nlayout: post\n\ntitle: 提升變數\ntip-number: 11\ntip-username: squizzleflip\ntip-username-profile: https://twitter.com/squizzleflip\ntip-tldr: JavaScript 模組以及建構步驟變得更多更複雜，但對於新的框架樣板呢？\n\ncategories:\n    - zh_TW\n---\n\n了解 [hoisting](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting) 將會幫助你編寫函式 scope。只要記得，變數宣告和函式定義都會被提升到頂端。變數定義則不會，即使你宣告和定義一個變數再同一行。變數**宣告**是讓系統知道變數的存在，而**定義**只是分配給它一個值。\n\n```javascript\nfunction doTheThing() {\n  // ReferenceError: notDeclared 沒有被定義\n  console.log(notDeclared);\n\n  // 輸出：undefine\n  console.log(definedLater);\n  var definedLater;\n\n  definedLater = 'I am defined!'\n  // 輸出：'I am defined!'\n  console.log(definedLater)\n\n  // 輸出：undefined\n  console.log(definedSimulateneously);\n  var definedSimulateneously = 'I am defined!'\n  // 輸出：'I am defined!'\n  console.log(definedSimulateneously)\n\n  // 輸出：'I did it!'\n  doSomethingElse();\n\n  function doSomethingElse(){\n    console.log('I did it!');\n  }\n\n  // TypeError: undefined 不是一個函式\n  functionVar();\n\n  var functionVar = function(){\n    console.log('I did it!');\n  }\n}\n```\n\n為了讓你的程式碼更容易閱讀，將你所有的變數宣告在你的函式 scope 頂端，這樣可以更清楚知道變數是來自哪個 scope。在你使用變數之前請先定義。在你的 scope 底部定義函式，來保持它們的方式。\n"},"2016-01-21-shuffle-an-array.md":{"name":"2016-01-21-shuffle-an-array.md","sha":"f19883b6bb563742891f7a957a379d8f2e87e94b","content":"---\nlayout: post\n\ntitle: 將陣列洗牌\ntip-number: 21\ntip-username: 0xmtn\ntip-username-profile: https://github.com/0xmtn/\ntip-tldr: Fisher-Yates Shuffling 是一個將陣列洗牌的演算法。\n\ncategories:\n    - zh_TW\n---\n\n這段程式碼使用了 [Fisher-Yates Shuffling](https://www.wikiwand.com/en/Fisher%E2%80%93Yates_shuffle) 演算法將給定的陣列洗牌。\n\n```javascript\nfunction shuffle(arr) {\n    var i,\n        j,\n        temp;\n    for (i = arr.length - 1; i > 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n    }\n    return arr;\n};\n```\n範例：\n\n```javascript\nvar a = [1, 2, 3, 4, 5, 6, 7, 8];\nvar b = shuffle(a);\nconsole.log(b);\n// [2, 7, 8, 6, 5, 3, 1, 4]\n```\n"},"2016-02-05-observe-dom-changes.md":{"name":"2016-02-05-observe-dom-changes.md","sha":"4fa2d5375ab663883ee2a8d15b28e9a543acb0a0","content":"---\nlayout: post\n\ntitle: 觀察在擴充中 DOM 的變化\ntip-number: 36\ntip-username: beyondns\ntip-username-profile: https://github.com/beyondns\ntip-tldr: 由於現代動態的 JavaScript，當你在現有的網站開發擴充時，操作 DOM 並不容易。\n\n\ncategories:\n    - zh_TW\n---\n[MutationObserver](https://developer.mozilla.org/en/docs/Web/API/MutationObserver) 是一個 listen DOM 的改變以及元素變化時的解決方法。在下面的範例是使用計時器模擬了內容動態載入，在第一個元素「target」建立後，接著建立「subTarget」。\n在擴充的程式碼中，首先 `rootObserver` 執行直到 `targetElement` 出現，然後 `elementObserver` 才開始執行。這個級聯觀察有助於直到最後發現 `subTargetElement`。\n這個在開發擴充複雜的網站與動態內容載入時相當有用。\n\n```js\nconst observeConfig = {\n    attributes: true,\n    childList: true,\n    characterData: true,\n    subtree: true\n};\n\nfunction initExtension(rootElement, targetSelector, subTargetSelector) {\n    var rootObserver = new MutationObserver(function(mutations) {\n        console.log(\"Inside root observer\");\n        targetElement = rootElement.querySelector(targetSelector);\n        if (targetElement) {\n            rootObserver.disconnect();\n            var elementObserver = new MutationObserver(function(mutations) {\n                console.log(\"Inside element observer\")\n                subTargetElement = targetElement.querySelector(subTargetSelector);\n                if (subTargetElement) {\n                    elementObserver.disconnect();\n                    console.log(\"subTargetElement found!\")\n                }\n            })\n            elementObserver.observe(targetElement, observeConfig);\n        }\n    })\n    rootObserver.observe(rootElement, observeConfig);\n}\n\n(function() {\n\n    initExtension(document.body, \"div.target\", \"div.subtarget\")\n\n    setTimeout(function() {\n        del = document.createElement(\"div\");\n        del.innerHTML = \"<div class='target'>target</div>\"\n        document.body.appendChild(del)\n    }, 3000);\n\n\n    setTimeout(function() {\n        var el = document.body.querySelector('div.target')\n        if (el) {\n            del = document.createElement(\"div\");\n            del.innerHTML = \"<div class='subtarget'>subtarget</div>\"\n            el.appendChild(del)\n        }\n    }, 5000);\n\n})()\n```\n"},"2016-02-16-basics-declarations.md":{"name":"2016-02-16-basics-declarations.md","sha":"699f05b2a9c9da3ca2f15a2674f6ffecc58070c3","content":"---\nlayout: post\n\ntitle: 宣告的基本知識\ntip-number: 47\ntip-username: adaniloff\ntip-username-profile: https://github.com/adaniloff\ntip-tldr: 了解並處理宣告。\n\ncategories:\n    - zh_TW\n---\n\n以下有不同的 JavaScript 變數宣告方式。\n註解和 `console.log` 應該可以足夠解釋在這裡發生了什麼：\n\n```js\nvar y, x = y = 1 //== var x; var y; x = y = 1\nconsole.log('--> 1:', `x = ${x}, y = ${y}`)\n\n// 將會印出\n//--> 1: x = 1, y = 1\n```\n\n首先，我們只是設定兩個變數，沒有其他的變數。\n\n```js\n;(() => {\n  var x = y = 2 // == var x; x = y = 2;\n  console.log('2.0:', `x = ${x}, y = ${y}`)\n})()\nconsole.log('--> 2.1:', `x = ${x}, y = ${y}`)\n\n// 將會印出\n//2.0: x = 2, y = 2\n//--> 2.1: x = 1, y = 2\n```\n\n你可以看到，程式碼只改變了全域的 y，因為我們還沒有宣告變數在 closure。\n\n```js\n;(() => {\n  var x, y = 3 // == var x; var y = 3;\n  console.log('3.0:', `x = ${x}, y = ${y}`)\n})()\nconsole.log('--> 3.1:', `x = ${x}, y = ${y}`)\n\n// 將會印出\n//3.0: x = undefined, y = 3\n//--> 3.1: x = 1, y = 2\n```\n\n現在我們透過 var 來宣告兩個變數。意思說它們只存在 closure 的 context。\n\n```js\n;(() => {\n  var y, x = y = 4 // == var x; var y; x = y = 4\n  console.log('4.0:', `x = ${x}, y = ${y}`)\n})()\nconsole.log('--> 4.1:', `x = ${x}, y = ${y}`)\n\n// 將會印出\n//4.0: x = 4, y = 4\n//--> 4.1: x = 1, y = 2\n```\n\n兩個變數已經使用 var 宣告，也設定了他們的值。既然 `local > global`，x 和 y 在 closure 內，意思說全域的 x 和 y 是不會改變的。\n\n```js\nx = 5 // == x = 5\nconsole.log('--> 5:', `x = ${x}, y = ${y}`)\n\n// 將會印出\n//--> 5: x = 5, y = 2\n```\n\n最後的結果是很明顯的。\n\n你可以測試這些程式碼並觀看結果，[感謝 babel](https://babeljs.io/repl/#?experimental=false&evaluate=true&loose=false&spec=false&code=var%20y%2C%20x%20%3D%20y%20%3D%201%20%2F%2F%3D%3D%20var%20x%3B%20var%20y%3B%20x%20%3D%20y%20%3D%201%0Aconsole.log('--%3E%201%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%0A%2F%2F%20Will%20print%0A%2F%2F--%3E%201%3A%20x%20%3D%201%2C%20y%20%3D%201%0A%0A%3B(()%20%3D%3E%20%7B%20%0A%20%20var%20x%20%3D%20y%20%3D%202%20%2F%2F%20%3D%3D%20var%20x%3B%20y%20%3D%202%3B%0A%20%20console.log('2.0%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%7D)()%0Aconsole.log('--%3E%202.1%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%0A%2F%2F%20Will%20print%0A%2F%2F2.0%3A%20x%20%3D%202%2C%20y%20%3D%202%0A%2F%2F--%3E%202.1%3A%20x%20%3D%201%2C%20y%20%3D%202%0A%0A%3B(()%20%3D%3E%20%7B%20%0A%20%20var%20x%2C%20y%20%3D%203%20%2F%2F%20%3D%3D%20var%20x%3B%20var%20y%20%3D%203%3B%0A%20%20console.log('3.0%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%7D)()%0Aconsole.log('--%3E%203.1%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%0A%2F%2F%20Will%20print%0A%2F%2F3.0%3A%20x%20%3D%20undefined%2C%20y%20%3D%203%0A%2F%2F--%3E%203.1%3A%20x%20%3D%201%2C%20y%20%3D%202%0A%0A%3B(()%20%3D%3E%20%7B%20%0A%20%20var%20y%2C%20x%20%3D%20y%20%3D%204%20%2F%2F%20%3D%3D%20var%20x%3B%20var%20y%3B%20x%20%3D%20y%20%3D%203%0A%20%20console.log('4.0%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%7D)()%0Aconsole.log('--%3E%204.1%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%0A%2F%2F%20Will%20print%0A%2F%2F4.0%3A%20x%20%3D%204%2C%20y%20%3D%204%0A%2F%2F--%3E%204.1%3A%20x%20%3D%201%2C%20y%20%3D%202%0A%0Ax%20%3D%205%20%2F%2F%20%3D%3D%20x%20%3D%205%0Aconsole.log('--%3E%205%3A'%2C%20%60x%20%3D%20%24%7Bx%7D%2C%20y%20%3D%20%24%7By%7D%60)%0A%0A%2F%2F%20Will%20print%0A%2F%2F--%3E%205%3A%20x%20%3D%205%2C%20y%20%3D%202)。\n\n更多可用的資訊在 [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var)。\n\n特別感謝 @kurtextrem 的合作 :)!\n"},"2016-01-04-sorting-strings-with-accented-characters.md":{"name":"2016-01-04-sorting-strings-with-accented-characters.md","sha":"e044164a3fdbe5bb8346fc7221e1c4b57ea69851","content":"---\nlayout: post\n\ntitle: 將帶有音節字元的字串進行排序\ntip-number: 04\ntip-username: loverajoel\ntip-username-profile: https://github.com/loverajoel\ntip-tldr: JavaScript 原生的 **sort** 方法讓我們可以排序陣列。做一個簡單的 `array.sort()`， 將每一個陣列元素視為字串並依字母排序。但是當你嘗試排序一個非 ASCII 字元陣列時，你會得到一個奇怪的結果。\n\ncategories:\n    - zh_TW\n---\n\nJavaScript 原生的 **[sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)** 方法讓我們可以排序陣列。做一個簡單的 `array.sort()`， 將每一個陣列元素視為字串並依字母排序。你可以提供你的[自定義排序](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters)函式。\n\n```javascript\n['Shanghai', 'New York', 'Mumbai', 'Buenos Aires'].sort();\n// [\"Buenos Aires\", \"Mumbai\", \"New York\", \"Shanghai\"]\n```\n\n但是當你嘗試排序一個非 ASCII 字元陣列像是： `['é', 'a', 'ú', 'c']`，你會得到奇怪的結果： `['c', 'e', 'á', 'ú']`。這個問題是因為排序功能只適用於英語。\n\n請看以下的範例：\n\n```javascript\n// 西班牙語\n['único','árbol', 'cosas', 'fútbol'].sort();\n// [\"cosas\", \"fútbol\", \"árbol\", \"único\"] // bad order\n\n// 德文\n['Woche', 'wöchentlich', 'wäre', 'Wann'].sort();\n// [\"Wann\", \"Woche\", \"wäre\", \"wöchentlich\"] // bad order\n```\n\n幸運的是，有兩種方法可以解決這個問題，由 ECMAScript 國際化 API 提供的 [localeCompare](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare) 和 [Intl.Collator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Collator)。\n\n> 這兩種方法都有他們自己的自定義參數設置可以更有效的解決這個問題。\n\n### 使用 `localeCompare()`\n\n```javascript\n['único','árbol', 'cosas', 'fútbol'].sort(function (a, b) {\n  return a.localeCompare(b);\n});\n// [\"árbol\", \"cosas\", \"fútbol\", \"único\"]\n\n['Woche', 'wöchentlich', 'wäre', 'Wann'].sort(function (a, b) {\n  return a.localeCompare(b);\n});\n// [\"Wann\", \"wäre\", \"Woche\", \"wöchentlich\"]\n```\n\n### 使用 `Intl.Collator()`\n\n```javascript\n['único','árbol', 'cosas', 'fútbol'].sort(Intl.Collator().compare);\n// [\"árbol\", \"cosas\", \"fútbol\", \"único\"]\n\n['Woche', 'wöchentlich', 'wäre', 'Wann'].sort(Intl.Collator().compare);\n// [\"Wann\", \"wäre\", \"Woche\", \"wöchentlich\"]\n```\n\n- 對於每一個方法，你可以自定義位置。\n- 根據 [Firefox](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare#Performance)，當比對大量的字串時，Intl.Collator 會更加快速。\n\n所以，當你在處理非英文語系的字串陣列時，記得使用這個方法來避免排序出現異常。\n"},"2016-01-10-check-if-a-property-is-in-a-object.md":{"name":"2016-01-10-check-if-a-property-is-in-a-object.md","sha":"d3d458184000898f06f949f3e1f11b06c32e1b69","content":"---\nlayout: post\n\ntitle: 檢查屬性是否存在物件內\ntip-number: 10\ntip-username: loverajoel\ntip-username-profile: https://www.twitter.com/loverajoel\ntip-tldr: 這些方法都是檢查屬性是否存在目前的物件內。\n\ncategories:\n    - zh_TW\n---\n\n當你檢查屬性是否存在目前的[物件](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects)內，你或許可以這麼做：\n\n```javascript\nvar myObject = {\n  name: '@tips_js'\n};\n\nif (myObject.name) { ... }\n\n```\n\n以上的方法是沒問題的，但是你必須知道對於這個問題有兩個原生的方法，[`in` 運算符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in)和 [`Object.hasOwnProperty`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/hasOwnProperty)。任何繼承 `Object` 的都可以使用這兩種方法。\n\n### 觀察之間較大的差別\n\n```javascript\nvar myObject = {\n  name: '@tips_js'\n};\n\nmyObject.hasOwnProperty('name'); // true\n'name' in myObject; // true\n\nmyObject.hasOwnProperty('valueOf'); // false, valueOf 繼承自原型鏈結\n'valueOf' in myObject; // true\n\n```\n\n兩者不同的地方在於確認的屬性深度不同。換句話說，如果直接在物件內確認 key 是可用的話，`hasOwnProperty` 只會回傳 true。然而，在 `in` 運算符沒辦法分辨之間的屬性是建立在物件或是繼承自原型鏈結的。\n\n這裡有其他的範例：\n\n```javascript\nvar myFunc = function() {\n  this.name = '@tips_js';\n};\nmyFunc.prototype.age = '10 days';\n\nvar user = new myFunc();\n\nuser.hasOwnProperty('name'); // true\nuser.hasOwnProperty('age'); // false, 因為 age 是繼承自原型鏈結\n```\n\n在[線上範例](https://jsbin.com/tecoqa/edit?js,console)確認吧！\n確認屬性是否存在在物件內的問題常見錯誤，我推薦閱讀關於這個問題的[討論](https://github.com/loverajoel/jstips/issues/62)。\n"},"2016-01-22-two-ways-to-empty-an-array.md":{"name":"2016-01-22-two-ways-to-empty-an-array.md","sha":"4b1ad68a77ff105507f7745abe9a00295f5b8c94","content":"---\nlayout: post\n\ntitle: 將陣列清空的兩種方法\ntip-number: 22\ntip-username: microlv\ntip-username-profile: https://github.com/microlv\ntip-tldr: 在 JavaScript 中當你相要清空陣列，有許多方法，但這是最具效能的方法。\n\ncategories:\n    - zh_TW\n---\n\n你定義了一個陣列然後你想清空陣列內的內容。\n通常你會這麼做：\n\n```javascript\n// 定義陣列\nvar list = [1, 2, 3, 4];\nfunction empty() {\n    // 清空陣列\n    list = [];\n}\nempty();\n```\n但是這裡有另一個更能具效能的清空陣列的方式。\n\n你應該像這樣使用程式碼：\n\n```javascript\nvar list = [1, 2, 3, 4];\nfunction empty() {\n    // 清空陣列\n    list.length = 0;\n}\nempty();\n```\n\n* `list = []` 將分配一個新的參考陣列給變數，而其他的參考則不受影響。\n這個意思是說，前面參考的陣列內容還存在記憶體中，導致記憶體洩漏。\n\n* `list.length = 0` 刪除陣列內所有的內容，也會影響到其他的參考。\n\n換句話說，假設你有兩個變數且參考到同一個陣列（`a = [1,2,3]; a2 = a;`），而你使用 `list.length = 0` 刪除陣列的內容，兩個參考（a 和 a2）將指向相同的空陣列。（如果你不想讓 a2 內容變成空的陣列，請不要使用這個方法！）\n\n思考一下這些會輸出什麼：\n\n```js\nvar foo = [1,2,3];\nvar bar = [1,2,3];\nvar foo2 = foo;\nvar bar2 = bar;\nfoo = [];\nbar.length = 0;\nconsole.log(foo, bar, foo2, bar2);\n\n// [] [] [1, 2, 3] []\n```\n\n在 Stackoverflow 了解更多的細節：\n[difference-between-array-length-0-and-array](http://stackoverflow.com/questions/4804235/difference-between-array-length-0-and-array)\n"},"2016-02-15-detect-document-ready-in-pure-js.md":{"name":"2016-02-15-detect-document-ready-in-pure-js.md","sha":"e7e7e4862cff1210d445f4839b9d60587224a9f2","content":"---\nlayout: post\n\ntitle: 使用 pure JavaScript 檢查文件是否準備\ntip-number: 46\ntip-username: loverajoel\ntip-username-profile: https://www.twitter.com/loverajoel\ntip-tldr: 可以跨瀏覽器，而且使用 pure JavaScript 來確認文件是否已經載入完成。\n\ncategories:\n    - zh_TW\n---\n\n可以跨瀏覽器，而且使用 pure JavaScript 來確認文件是否已經載入完成的方式是使用 [`readyState`](https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState)。\n\n```js\nif (document.readyState === 'complete') {\n\t// 網頁已經完全載入\n}\n```\n\n當文件載入後，你可以檢查文件是否載入完成...\n\n\n```js\nlet stateCheck = setInterval(() => {\n\tif (document.readyState === 'complete') {\n    clearInterval(stateCheck);\n\t // 文件載入\n  }\n}, 100);\n```\n\n或使用 [onreadystatechange](https://developer.mozilla.org/en-US/docs/Web/Events/readystatechange)...\n\n\n```js\ndocument.onreadystatechange = () => {\n  if (document.readyState === 'complete') {\n   // 文件載入\n  }\n};\n```\n\n當 DOM 載入後，使用 `document.readyState === 'interactive'` 來檢查是否載入完成。\n"},"2016-02-08-advanced-properties.md":{"name":"2016-02-08-advanced-properties.md","sha":"727b949e1dd2f0163866de5ad3ae94d96b0382b2","content":"---\nlayout: post\n\ntitle: 進階 JavaScript 屬性\ntip-number: 39\ntip-username: mallowigi\ntip-username-profile: https://github.com/mallowigi\ntip-tldr: 如何加入私有屬性、getters 和 setters 到物件。\n\n\ncategories:\n    - zh_TW\n---\n\n在 JavaScript 可以設定物件屬性，例如：將屬性設定成偽私有或是唯讀。這是 ECMAScript 5.1 可用的功能，因此支援所有現代的瀏覽器。\n\n如果需要這麼做，你需要使用 `Object` 的 `defineProperty` 方法，像是：\n\n```js\nvar a = {};\nObject.defineProperty(a, 'readonly', {\n  value: 15,\n  writable: false\n});\n\na.readonly = 20;\nconsole.log(a.readonly); // 15\n```\n\n語法如下：\n```js\nObject.defineProperty(dest, propName, options)\n```\n\n或是多個定義：\n```js\nObject.defineProperties(dest, {\n  propA: optionsA,\n  propB: optionsB, //...\n})\n```\n\n其中，包括以下可選的屬性：\n- *value*：如果屬性不是 getter（如下），數值是必要的屬性。`{a: 12}` === `Object.defineProperty(obj, 'a', {value: 12})`\n- *writable*：將屬性設定為唯讀。請注意，如果該屬性是巢狀的物件，該屬性是仍然可以編輯。\n- *enumerable*：將屬性設定為隱藏。這意思說，在 `for ... of` 迴圈和 `stringify` 的結果不包含屬性，但屬性仍然存在。注意：這不代表屬性為私有的！它依然可以從外部存取，它只是不會列印出來。\n- *configurable*：將屬性設定為不可修改。防止刪除或重新定義。再者，如果該屬性是一個巢狀的物件，其屬性仍然可以設定。\n\n\n因此，為了建立一個私有的常數屬性，你像可以這樣定義：\n\n```js\nObject.defineProperty(obj, 'myPrivateProp', {value: val, enumerable: false, writable: false, configurable: false});\n```\n\n除了設定屬性，由於第二個參數是一個字串，`defineProperty` 允許我們定義*動態屬性*。舉個例子，比如說我想要根據一些外部設定來建立屬性：\n\n```js\n\nvar obj = {\n  getTypeFromExternal(): true // 違反 ES5.1 規則\n}\n\nObject.defineProperty(obj, getTypeFromExternal(), {value: true}); // ok\n\n// 因為範例緣故， ES6 引入了一個新語法：\nvar obj = {\n  [getTypeFromExternal()]: true\n}\n```\n\n但是這還不是全部！進階屬性允許我們建立 **getters** 和 **setters**，就像其他物件導向語言一樣！在這個情況下，我們不能使用 `writable`、`enumerable` 和 `configurable` 屬性，而是：\n\n```js\nfunction Foobar () {\n  var _foo; //  true 私有屬性\n\n  Object.defineProperty(obj, 'foo', {\n    get: function () { return _foo; }\n    set: function (value) { _foo = value }\n  });\n\n}\n\nvar foobar = new Foobar();\nfoobar.foo; // 15\nfoobar.foo = 20; // _foo = 20\n```\n\n除了有明顯的封裝和存取的優點，你可以注意到我們沒有「呼叫」getter，相反的，我們只是「取得」不帶括號的屬性！這太棒了！舉個例子，讓我們想像我們有一個物件具有多層巢狀的屬性，像是：\n\n```js\nvar obj = {a: {b: {c: [{d: 10}, {d: 20}] } } };\n```\n\n現在我們不需要做 `a.b.c[0].d`（其中某個屬性可以解析成 `undefined` 然後拋出錯誤），我們可以建立另一個別名：\n\n```js\nObject.defineProperty(obj, 'firstD', {\n  get: function () { return a && a.b && a.b.c && a.b.c[0] && a.b.c[0].d }\n})\n\nconsole.log(obj.firstD) // 10\n```\n\n### 注意\n如果你定義一個 getter 而沒有一個 setter 然後你想要嘗試設定數值，你會得到一個錯誤！當使用輔助函式像是 `$.extend` 或 `_.merge`，這是相當重要的一部份。請小心使用！\n\n### 連結\n\n- [defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)\n- [在 JavaScript 中定義屬性](http://bdadam.com/blog/defining-properties-in-javascript.html)\n"},"2015-12-29-insert-item-inside-an-array.md":{"name":"2015-12-29-insert-item-inside-an-array.md","sha":"b9aba6f31f540e9213207bc793794b724c4f3b3f","content":"---\nlayout: post\n\ntitle: 在陣列中加入元素\ntip-number: 00\ntip-username: loverajoel\ntip-username-profile: https://github.com/loverajoel\ntip-tldr: 在一個存在的陣列加入新的元素是一件很常見的事情，你可以使用 push 將元素加入到陣列的末端，或是使用 unshift 在陣列起始位置加入元素，也可以使用 splice 在陣列中間的地方加入元素。\n\n\ncategories:\n    - zh_TW\n---\n\n# 在存在的陣列加入新的元素\n\n在一個存在的陣列加入新的元素是一件很常見的事情，你可以使用 push 將元素加入到陣列的末端，或是使用 unshift 在陣列起始位置加入元素，也可以使用 splice 在陣列中間的地方加入元素。\n\n那些都是已知的方法，但這並不代表沒有更好的效能的方法。讓我們開始吧:\n\n## 在陣列最後加入新的元素\n\n在陣列最後加入新的元素我們可以簡單地透過 push() 方式，但以下是更能提升效能方法。\n\n```javascript\nvar arr = [1, 2, 3, 4, 5];\nvar arr2 = [];\n\narr.push(6);\narr[arr.length] = 6;\narr2 = arr.concat([6]);\n```\n這兩種方法都是修改原始的陣列。不相信嗎？請參考 [jsperf](http://jsperf.com/push-item-inside-an-array)。\n\n### 在 mobile 上的性能表現：\n\n#### Android (v4.2.2)\n\n1. _arr.push(6);_ 和 _arr[arr.length] = 6;_ 有相同的性能表現 // 3 319 694 ops/sec\n3. _arr2 = arr.concat([6]);_ 較以上兩個方法慢 50.61 %\n\n#### Chrome Mobile (v33.0.0)\n\n1. _arr[arr.length] = 6;_ // 6 125 975 ops/sec\n2. _arr.push(6);_ 慢 66.74 %\n3. _arr2 = arr.concat([6]);_ 慢 87.63 %\n\n#### Safari Mobile (v9)\n\n1. _arr[arr.length] = 6;_ // 7 452 898 ops/sec\n2. _arr.push(6);_ 慢 40.19 %\n3. _arr2 = arr.concat([6]);_ 慢 49.78 %\n\n```javascript\n最後勝利者\n\n1. arr[arr.length] = 6; // 平均 5 632 856 ops/sec\n2. arr.push(6); // 慢 35.64 %\n3. arr2 = arr.concat([6]); // 慢 62.67 %\n```\n\n### 在 desktop 的性能表現\n\n#### Chrome (v48.0.2564)\n\n1. _arr[arr.length] = 6;_ // 21 602 722 ops/sec\n2. _arr.push(6);_ 慢 61.94 %\n3. _arr2 = arr.concat([6]);_ 慢 87.45 %\n\n#### Firefox (v44)\n\n1. _arr.push(6);_ // 56 032 805 ops/sec\n2. _arr[arr.length] = 6;_ 慢 0.52 %\n3. _arr2 = arr.concat([6]);_ 慢 87.36 %\n\n#### IE (v11)\n\n1. _arr[arr.length] = 6;_ // 67 197 046 ops/sec\n2. _arr.push(6);_ 慢 39.61 %\n3. _arr2 = arr.concat([6]);_ 慢 93.41 %\n\n#### Opera (v35.0.2066.68)\n\n1. _arr[arr.length] = 6;_ // 30 775 071 ops/sec\n2. _arr.push(6);_ 慢 71.60 %\n3. _arr2 = arr.concat([6]);_ 慢 83.70 %\n\n#### Safari (v9.0.3)\n\n1. _arr.push(6);_ // 42 670 978 ops/sec\n2. _arr[arr.length] = 6;_ 慢 0.80 %\n3. _arr2 = arr.concat([6]);_ 慢 76.07 %\n\n```javascript\n最後勝利者\n\n1. arr[arr.length] = 6; // 平均 42 345 449 ops/sec\n2. arr.push(6); // 慢 34.66 %\n3. arr2 = arr.concat([6]); // 慢 85.79 %\n```\n\n## 在陣列起始加入元素\n\n現在我們嘗試在陣列的起始加入元素：\n\n```javascript\nvar arr = [1, 2, 3, 4, 5];\n\narr.unshift(0);\n[0].concat(arr);\n```\n這裡有更多小細項：unshift 修改原始陣列；concat 回傳一個新的陣列。[jsperf](http://jsperf.com/unshift-item-inside-an-array)\n\n### 在 mobile 的性能表現：\n\n#### Android (v4.2.2)\n\n1. _[0].concat(arr);_ // 1 808 717 ops/sec\n2. _arr.unshift(0);_ 慢 97.85 %\n\n#### Chrome Mobile (v33.0.0)\n\n1. _[0].concat(arr);_ // 1 269 498 ops/sec\n2. _arr.unshift(0);_ 慢 99.86 %\n\n#### Safari Mobile (v9)\n\n1. _arr.unshift(0);_ // 3 250 184 ops/sec\n2. _[0].concat(arr);_ 慢 33.67 %\n\n```javascript\n最後勝利者\n\n1. [0].concat(arr); // 平均 4 972 622 ops/sec\n2. arr.unshift(0); // 慢 64.70 %\n```\n\n### 在 desktop 的性能表現\n\n#### Chrome (v48.0.2564)\n\n1. _[0].concat(arr);_ // 2 656 685 ops/sec\n2. _arr.unshift(0);_ 慢 96.77 %\n\n#### Firefox (v44)\n\n1. _[0].concat(arr);_ // 8 039 759 ops/sec\n2. _arr.unshift(0);_ 慢 99.72 %\n\n#### IE (v11)\n\n1. _[0].concat(arr);_ // 3 604 226 ops/sec\n2. _arr.unshift(0);_ 慢 98.31 %\n\n#### Opera (v35.0.2066.68)\n\n1. _[0].concat(arr);_ // 4 102 128 ops/sec\n2. _arr.unshift(0);_ 慢 97.44 %\n\n#### Safari (v9.0.3)\n\n1. _arr.unshift(0);_ // 12 356 477 ops/sec\n2. _[0].concat(arr);_ 慢 15.17 %\n\n```javascript\n最後勝利者\n\n1. [0].concat(arr); // 平均 6 032 573 ops/sec\n2. arr.unshift(0); // 慢 78.65 %\n```\n\n## 在陣列中間加入元素\n\n在陣列中間可以簡單透過 splice 來加入元素，這樣的做法是最具效能的方式。\n\n```javascript\nvar items = ['one', 'two', 'three', 'four'];\nitems.splice(items.length / 2, 0, 'hello');\n```\n\n我嘗試在不同的瀏覽器和 OS 執行這些測試，他們的結果是相似的。我希望這些知識對你是有幫助的，也鼓勵你自己進行測試！"},"2016-02-04-assignment-shorthands.md":{"name":"2016-02-04-assignment-shorthands.md","sha":"07de399099881e2046b107844faaf051bb2f46e4","content":"---\nlayout: post\n\ntitle: 賦值運算子\ntip-number: 35\ntip-username: hsleonis\ntip-username-profile: https://github.com/hsleonis\ntip-tldr: 賦值是相當常見的。有時候我們這些「懶惰的開發者」覺得打字是很耗時的。所以我們使用一些技巧來幫助我們讓程式碼更乾淨簡單。\n\ncategories:\n    - zh_TW\n---\n\n賦值是相當常見的。有時候我們這些「懶惰的開發者」覺得打字是很耗時的。所以我們使用一些技巧來幫助我們讓程式碼更乾淨簡單。\n\n這是類似的方法\n\n````javascript\nx += 23; // x = x + 23;\ny -= 15; // y = y - 15;\nz *= 10; // z = z * 10;\nk /= 7; // k = k / 7;\np %= 3; // p = p % 3;\nd **= 2; // d = d ** 2;\nm >>= 2; // m = m >> 2;\nn <<= 2; // n = n << 2;\nn ++; // n = n + 1;\nn --; n = n - 1;\n\n````\n\n### `++` 和 `--` 運算子\n\n這是一個特殊的 `++` 運算子。透過範例來做一個更好的解釋：\n\n````javascript\nvar a = 2;\nvar b = a++;\n// 現在 a 是 3 然後 b 是 2\n````\n\n`a++` 執行以下的操作：\n  1. 回傳 `a` 的數值\n  2. 將 `a` 加 1\n\n如果我們想要先把數值加一呢？很簡單的：\n\n````javascript\nvar a = 2;\nvar b = ++a;\n// 現在 a 和 b 都是 3\n````\n\n看見了嗎？我把運算子放在變數_之前_。\n\n`--` 運算子也是類似的，用來遞減數值。\n\n### If-else （使用三元運算符）\n\n這是我們一般常見的寫法：\n\n````javascript\nvar newValue;\nif (value > 10)\n  newValue = 5;\nelse\n  newValue = 2;\n````\n\n我們可以使用三元運算符看起來更棒：\n\n````javascript\nvar newValue = (value > 10) ? 5 : 2;\n````\n\n### Null、Undefined、Empty 確認\n\n````javascript\nif (variable1 !== null || variable1 !== undefined || variable1 !== '') {\n     var variable2 = variable1;\n}\n````\n\n簡化後：\n\n````javascript\nvar variable2 = variable1  || '';\n````\nP.S.：假設 variable1 是數字，首先會檢查是否為 0 。\n\n### 物件陣列表示\n\n不是使用：\n\n````javascript\nvar a = new Array();\na[0] = \"myString1\";\na[1] = \"myString2\";\n````\n而是這樣使用：\n\n````javascript\nvar a = [\"myString1\", \"myString2\"];\n````\n\n### 關聯陣列\n\n不是使用：\n\n````javascript\nvar skillSet = new Array();\nskillSet['Document language'] = 'HTML5';\nskillSet['Styling language'] = 'CSS3';\n````\n\n而是這樣使用：\n\n````javascript\nvar skillSet = {\n    'Document language' : 'HTML5',\n    'Styling language' : 'CSS3'\n};\n````\n"},"2016-01-03-improve-nested-conditionals.md":{"name":"2016-01-03-improve-nested-conditionals.md","sha":"798c923d00ad4055bdf1869122f318f1d0ab446f","content":"---\nlayout: post\n\ntitle: 改善巢狀化的條件式\ntip-number: 03\ntip-username: AlbertoFuente\ntip-username-profile: https://github.com/AlbertoFuente\ntip-tldr: 我們要如何在 JavaScript 改善巢狀化的 `if` 條件式？\n\ncategories:\n    - zh_TW\n---\n\n我們要如何在 JavaScript 改善巢狀化的 `if` 條件式？\n\n```javascript\nif (color) {\n  if (color === 'black') {\n    printBlackBackground();\n  } else if (color === 'red') {\n    printRedBackground();\n  } else if (color === 'blue') {\n    printBlueBackground();\n  } else if (color === 'green') {\n    printGreenBackground();\n  } else {\n    printYellowBackground();\n  }\n}\n```\n\n有一種方式可以改善巢狀化的 `if` 條件式是使用 `switch` 陳述式。雖然更簡潔有序，但是不建議使用，因為它不容易 debug 錯誤。告訴你[為什麼](https://toddmotto.com/deprecating-the-switch-statement-for-object-literals)。\n\n```javascript\nswitch(color) {\n  case 'black':\n    printBlackBackground();\n    break;\n  case 'red':\n    printRedBackground();\n    break;\n  case 'blue':\n    printBlueBackground();\n    break;\n  case 'green':\n    printGreenBackground();\n    break;\n  default:\n    printYellowBackground();\n}\n```\n\n但是，如果我們語句中都有很多條件檢查呢？在這個情況下，如果我們想要讓它更簡潔有序，我們可以使用有條件的 `switch`。\n如果我們傳送 `true` 當作參數給 `switch` 陳述式，允許我們在每個 case 下使用條件式。\n\n```javascript\nswitch(true) {\n  case (typeof color === 'string' && color === 'black'):\n    printBlackBackground();\n    break;\n  case (typeof color === 'string' && color === 'red'):\n    printRedBackground();\n    break;\n  case (typeof color === 'string' && color === 'blue'):\n    printBlueBackground();\n    break;\n  case (typeof color === 'string' && color === 'green'):\n    printGreenBackground();\n    break;\n  case (typeof color === 'string' && color === 'yellow'):\n    printYellowBackground();\n    break;\n}\n```\n\n但是我們必須避免使用過多的條件檢查以及避免使用 `switch`。我們使用最有效率的方式，透過 `object`。\n\n```javascript\nvar colorObj = {\n  'black': printBlackBackground,\n  'red': printRedBackground,\n  'blue': printBlueBackground,\n  'green': printGreenBackground,\n  'yellow': printYellowBackground\n};\n\nif (color in colorObj) {\n  colorObj[color]();\n}\n```\n\n這裡你可以找到更多的資訊關於 [switch](http://www.nicoespeon.com/en/2015/01/oop-revisited-switch-in-js/)。\n"},"2016-01-09-template-strings.md":{"name":"2016-01-09-template-strings.md","sha":"59347681d4ab75581f64b32e2b03170deeb881d3","content":"---\nlayout: post\n\ntitle: 模板字串\ntip-number: 09\ntip-username: JakeRawr\ntip-username-profile: https://github.com/JakeRawr\ntip-tldr: 由於 ES6 中有了模板字串，JavaScript 可以使用模板字串來替代原本我們使用的引號字元。\n\ncategories:\n    - zh_TW\n---\n\n由於 ES6 中有了模板字串，JavaScript 可以使用模板字串來替代原本我們使用的引號字元。\n\nEx:\n正常的字串\n\n```javascript\nvar firstName = 'Jake';\nvar lastName = 'Rawr';\nconsole.log('My name is ' + firstName + ' ' + lastName);\n// My name is Jake Rawr\n```\n模板字串\n\n```javascript\nvar firstName = 'Jake';\nvar lastName = 'Rawr';\nconsole.log(`My name is ${firstName} ${lastName}`);\n// My name is Jake Rawr\n```\n\n在模板字串中，你不需要透過 `\\n` 來產生多行的字串，只要簡單透過 `${}` 來替代就可以了，還可以計算簡單的邏輯，例如：`${2 + 3}`。\n你也可以使用函式來修改你的輸出的內容；例如使用標籤模板字串，它們被稱為[標籤模板字串](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/template_strings#Tagged_template_strings)。\n\n你或許想要[閱讀](https://hacks.mozilla.org/2015/05/es6-in-depth-template-strings-2)和了解更多關於模板字串。\n"},"2016-01-06-writing-a-single-method-for-arrays-and-a-single-element.md":{"name":"2016-01-06-writing-a-single-method-for-arrays-and-a-single-element.md","sha":"a69e1e3294084826dcb52a8f52294e6e4fa3c879","content":"---\nlayout: post\n\ntitle: 撰寫一個可以接受單一參數和陣列的方法\ntip-number: 06\ntip-username: mattfxyz\ntip-username-profile: https://twitter.com/mattfxyz\ntip-tldr: 你撰寫的函式要可以處理陣列或單一元素參數，而不是透過分開的方法來處理陣列和單一元素參數。這和 jQuery 一些函式工作原理相似（`css` 將會修改所有和 selector matched 的）。\n\ncategories:\n    - zh_TW\n---\n\n你撰寫的函式要可以處理陣列或單一元素參數，而不是透過分開的方法來處理陣列和單一元素參數。這和 jQuery 一些函式工作原理相似（`css` 將會修改所有和 selector matched 的）。\n\n首先，你只要將任何的東西 concat 到陣列上。`Array.concat` 將會接受陣列或是單一元素。\n\n```javascript\nfunction printUpperCase(words) {\n  var elements = [].concat(words || []);\n  for (var i = 0; i < elements.length; i++) {\n    console.log(elements[i].toUpperCase());\n  }\n}\n```\n\n`printUpperCase` 現在已經可以接收單一的 node 或是一個陣列 nodes 當作它的參數了。如果沒有傳送參數，它可以避免拋出潛在的 `TypeError`。\n\n```javascript\nprintUpperCase(\"cactus\");\n// => CACTUS\nprintUpperCase([\"cactus\", \"bear\", \"potato\"]);\n// => CACTUS\n//  BEAR\n//  POTATO\n```\n"},"2016-02-07-flattening-multidimensional-arrays-in-javascript.md":{"name":"2016-02-07-flattening-multidimensional-arrays-in-javascript.md","sha":"cfbd372a917a1bb3c2dafc03e0c1bf00f5a4c2fc","content":"---\nlayout: post\n\ntitle: 在 JavaScript 中將多維陣列扁平化\ntip-number: 38\ntip-username: loverajoel\ntip-username-profile: https://www.twitter.com/loverajoel\ntip-tldr: 三種不同的解決方法，將多維陣列合併為單一的陣列。\n\n\ncategories:\n    - zh_TW\n---\n\n三種不同的解決方法，將多維陣列合併為單一的陣列。\n\n給定一個陣列：\n\n```js\nvar myArray = [[1, 2],[3, 4, 5], [6, 7, 8, 9]];\n```\n\n我們想到得到這個結果：\n\n```js\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n### 方案一: 使用 [`concat()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/concat) 和 [`apply()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply)\n\n```js\nvar myNewArray = [].concat.apply([], myArray);\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n### 方案二：使用 [`reduce()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Flatten_an_array_of_arrays)\n\n```js\nvar myNewArray = myArray.reduce(function(prev, curr) {\n  return prev.concat(curr);\n});\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n\n### 方案三：\n\n```js\nvar myNewArray3 = [];\nfor (var i = 0; i < myArray.length; ++i) {\n  for (var j = 0; j < myArray[i].length; ++j)\n    myNewArray3.push(myArray[i][j]);\n}\nconsole.log(myNewArray3);\n// [1, 2, 3, 4, 5, 6, 7, 8, 9]\n```\n在[這裡](https://jsbin.com/qeqicu/edit?js,console)觀察三種方式的實際應用。\n\n對於較大的巢狀陣列可以嘗試使用 Underscore 的 [flatten()](https://github.com/jashkenas/underscore/blob/master/underscore.js#L501)。\n\n如果你好奇效能方面的表現, [這裡](http://jsperf.com/flatten-an-array-loop-vs-reduce/6)有相關的測試。\n"},"2016-01-16-passing-arguments-to-callback-functions.md":{"name":"2016-01-16-passing-arguments-to-callback-functions.md","sha":"a50f64e9946802f0978d345031fa8605517772ae","content":"---\nlayout: post\n\ntitle: 將參數傳送到 callback 函式\ntip-number: 16\ntip-username: minhazav\ntip-username-profile: https://twitter.com/minhazav\ntip-tldr: JavaScript 模組以及建構步驟變得更多更複雜，但對於新的框架樣板呢？\n\ncategories:\n    - zh_TW\n---\n\n預設情況下，你不能傳送參數給 callback 函式。例如：\n\n```js\nfunction callback() {\n  console.log('Hi human');\n}\n\ndocument.getElementById('someelem').addEventListener('click', callback);\n\n```\n\n你可以利用 JavaScript 閉包（closure）scope 的優點傳送參數給 callback 函式。看一下這個範例：\n\n```js\nfunction callback(a, b) {\n  return function() {\n    console.log('sum = ', (a+b));\n  }\n}\n\nvar x = 1, y = 2;\ndocument.getElementById('someelem').addEventListener('click', callback(x, y));\n\n```\n\n### 什麼是閉包（closure）？\n\nClosures 指的是一個獨立的變數函式。換句話說，在閉包中定義的函式「記得」它被建立時的環境。在 [MDN 文件](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)了解更多。\n\n當 callback 函式被呼叫時，這些方法的參數 `x` 和 `y` 都會在 callback 函式的範圍內。\n\n另一個方法你可以使用 `bind`。例如：\n\n```js\nvar alertText = function(text) {\n  alert(text);\n};\n\ndocument.getElementById('someelem').addEventListener('click', alertText.bind(this, 'hello'));\n```\n兩種方法上有細微的性能上的差別，請參考 [jsperf](http://jsperf.com/bind-vs-closure-23)。\n"},"2016-01-19-safe-string-concatenation.md":{"name":"2016-01-19-safe-string-concatenation.md","sha":"db81b75d9ed0bbdab4ef18d007d4813fe7c7d061","content":"---\nlayout: post\n\ntitle: 安全的使用字串串接\ntip-number: 19\ntip-username: gogainda\ntip-username-profile: https://twitter.com/gogainda\ntip-tldr: 假設你有一些不確定的變數類型，而你想將它們串接成字串。可以確定的是，算術運算不是應用在串接的地方，使用 concat 來串接。\n\ncategories:\n    - zh_TW\n---\n\n假設你有一些不確定的變數類型，而你想將它們串接成字串。可以肯定的是，算術運算符不是在串接過程的運用，請使用 `concat`：\n\n```javascript\nvar one = 1;\nvar two = 2;\nvar three = '3';\n\nvar result = ''.concat(one, two, three); // \"123\"\n```\n\n這個方法串接結果是你預期的。相反的，透過加號來串接會造成非預期的結果：\n\n```javascript\nvar one = 1;\nvar two = 2;\nvar three = '3';\n\nvar result = one + two + three; // \"33\" 而不是 \"123\"\n```\n\n關於性能部分，與 `join` [類型](http://www.sitepoint.com/javascript-fast-string-concatenation/)比較，串接速度和 `concat` 是差不多的。\n\n你可以在 MDN [網頁](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/concat)上閱讀到更多關於 `concat` 函式的資訊。\n"},"2016-01-31-avoid-modifying-or-passing-arguments-into-other-functions—it-kills-optimization.md":{"name":"2016-01-31-avoid-modifying-or-passing-arguments-into-other-functions—it-kills-optimization.md","sha":"c642e707e3aed8d412f62251c250214e28dee09a","content":"---\nlayout: post\n\ntitle: 避免修改或傳送 arguments 到其他函式 - 它會影響優化\ntip-number: 31\ntip-username: berkana\ntip-username-profile: https://github.com/berkana\ntip-tldr: 在 JavaScript 的函式，變數名稱 `arguments` 讓你可以存取所有傳送到函式的參數。`arguments` 是一個 *類陣列物件*；`arguments` 可以使用陣列表示來存取，而且它有 *length* 屬性，但不具備陣列的 `filter` 和 `map` 以及 `forEach` 的方法。以下程式碼是轉換 `arguments` 到陣列相當普遍的做法。\n\n\ncategories:\n    - zh_TW\n---\n\n### 背景\n\n在 JavaScript 的函式，變數名稱 [`arguments`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments) 讓你可以存取所有傳送到函式的參數。`arguments` 是一個 *類陣列物件*；`arguments` 可以使用陣列表示來存取，而且它有 *length* 屬性，但不具備陣列的 `filter` 和 `map` 以及 `forEach` 的方法。以下程式碼是轉換 `arguments` 到陣列相當普遍的做法。\n\n```js\nvar args = Array.prototype.slice.call(arguments);\n```\n將 `arguments` 傳送到 `Array` 原型的上的 `slice` 方法；`slice` 方法回傳淺拷貝的 `arguments` 當作新的陣列物件。一般常見的簡寫方法：\n\n```js\nvar args = [].slice.call(arguments);\n```\n在這個情況下，只是呼叫一個空陣列陣列，而不是從 `Array` 原型上呼叫 `slice` 方法。\n\n### 優化\n\n不幸的是，傳送到任何函式呼叫的 `arguments`，造成在 Chrome 和 Node 跳過 JavaScript V8 引擎的優化功能，這可能會導致性能降低。參考這篇 [optimization killers](https://github.com/petkaantonov/bluebird/wiki/Optimization-killers) 文章。傳送 `arguments` 到函式稱為 *leaking `arguments`*。\n\n相反的，假設你需要包含參數的陣列，你可以藉助這個方法：\n\n```js\nvar args = new Array(arguments.length);\nfor(var i = 0; i < args.length; ++i) {\n  args[i] = arguments[i];\n}\n```\n\n雖然程式碼更冗長，但是在上線環境增進了效能的優化，所以是值得的。\n"},"2016-01-23-converting-to-number-fast-way.md":{"name":"2016-01-23-converting-to-number-fast-way.md","sha":"ce4f37a91cc6ab70c249109a71c173fe9419dea3","content":"---\nlayout: post\n\ntitle: 轉換為數字更快的方式\ntip-number: 23\ntip-username: sonnyt\ntip-username-profile: http://twitter.com/sonnyt\ntip-tldr: 轉換字串為數字是相當常見的。最簡單和快速的方式是使用 + 運算子來實現。\n\ncategories:\n    - zh_TW\n---\n\n轉換字串為數字是相當常見的。最簡單和快速的方式是使用 `+` （加號）運算子來實現。（[jsPerf](https://jsperf.com/number-vs-parseint-vs-plus/29)）\n\n```javascript\nvar one = '1';\n\nvar numberOne = +one; // Number 1\n```\n\n你也可以使用 `-` （減號）運算子將數字類型轉換成負數。\n\n```javascript\nvar one = '1';\n\nvar negativeNumberOne = -one; // Number -1\n```\n"},"2016-01-02-keys-in-children-components-are-important.md":{"name":"2016-01-02-keys-in-children-components-are-important.md","sha":"bc8ef7a5f441f8440a99e59b29f13b7507cc3dcc","content":"---\nlayout: post\n\ntitle: 在子元件 Keys 是很重要的\ntip-number: 02\ntip-username: loverajoel\ntip-username-profile: https://github.com/loverajoel\ntip-tldr: 你可以從陣列動態建立 key 屬性並傳送到所有的元件（component）。它是一個唯一以及固定的 id，React 用來識別 DOM 裡面的每個元件，並區別它是否為同一個元件。使用 keys 可以確保子元件被保護而不會被重覆建立，也可以防止奇怪的事件發生。\n\ncategories:\n    - zh_TW\n---\n\n你可以從陣列動態建立 [key](https://facebook.github.io/react/docs/multiple-components.html#dynamic-children) 屬性並傳送到所有的元件（component）。它是一個唯一以及固定的 id，React 用來識別 DOM 裡面的每個元件，並區別它是否為同一個元件。使用 keys 可以確保子元件被保護而不會被重覆建立，也可以防止奇怪的事件發生。\n\n> Key 跟效能不太相關，它跟元件識別較有關係（反之，它間接提升了效能）。隨機賦值和改變數值將無法識別。[Paul O’Shannessy](https://github.com/facebook/react/issues/1342#issuecomment-39230939)\n\n- 使用物件內存在的唯一值。\n- 在你的父元件定義 keys，而不是子元件。\n\n```javascript\n//bad\n...\nrender() {\n\t<div key={{item.key}}>{{item.name}}</div>\n}\n...\n\n//good\n<MyComponent key={{item.key}}/>\n```\n- [使用陣列索引是不好的習慣。](https://medium.com/@robinpokorny/index-as-a-key-is-an-anti-pattern-e0349aece318#.76co046o9)\n- `random()` 將無法使用。\n\n```javascript\n//bad\n<MyComponent key={{Math.random()}}/>\n```\n\n\n- 你可以建立你自己唯一的 id。確認這個方法夠快速可以附加到你的物件上。\n- 當你的子元件數量很多或者含有龐大的元件，使用 keys 可以提高效能。\n- [你必須提供 key 屬性給 ReactCSSTransitionGroup 的所有子元件。](http://docs.reactjs-china.com/react/docs/animation.html)\n"},"2016-02-09-using-json-stringify.md":{"name":"2016-02-09-using-json-stringify.md","sha":"8b1644954ed27b21699fd0a070240ec324b4857f","content":"---\nlayout: post\n\ntitle: 使用 JSON.Stringify\ntip-number: 40\ntip-username: vamshisuram\ntip-username-profile: https://github.com/vamshisuram\ntip-tldr: 從 JSON 物件中，將被選到的屬性建立成字串。\n\n\ncategories:\n    - zh_TW\n---\n\n假設有一個物件有「prop1」、「prop2」、「prop3」屬性。\n我們傳送__額外的參數__到 __JSON.stringify__ 將物件的屬性變成字串，像是：\n\n```javascript\nvar obj = {\n    'prop1': 'value1',\n    'prop2': 'value2',\n    'prop3': 'value3'\n};\n\nvar selectedProperties = ['prop1', 'prop2'];\n\nvar str = JSON.stringify(obj, selectedProperties);\n\n// str\n// {\"prop1\":\"value1\",\"prop2\":\"value2\"}\n\n```\n\n__\"str\"__ 只包含被選擇到的屬性的資訊。\n\n除了傳送陣列，我們也可以傳送函式。\n\n```javascript\n\nfunction selectedProperties(key, val) {\n    // 第一個數值是整個物件，key 是空的字串\n    if (!key) {\n        return val;\n    }\n\n    if (key === 'prop1' || key === 'prop2') {\n        return val;\n    }\n\n    return;\n}\n```\n\n最後一個可選參數式是修改物件寫入字串的方式。\n\n```javascript\nvar str = JSON.stringify(obj, selectedProperties, '\\t\\t');\n\n/* str 每個輸出會有 doube tabs。\n{\n        \"prop1\": \"value1\",\n        \"prop2\": \"value2\"\n}\n*/\n\n```\n"},"2016-01-12-pseudomandatory-parameters-in-es6-functions.md":{"name":"2016-01-12-pseudomandatory-parameters-in-es6-functions.md","sha":"44c7d890b33090a54c9ede20d04a5d71334e9f7f","content":"---\nlayout: post\n\ntitle: 在 ES6 函式內的預設參數\ntip-number: 12\ntip-username: Avraam Mavridis\ntip-username-profile: https://github.com/AvraamMavridis\ntip-tldr: 在許多程式設計語言函數的參數預設是強制需要的，而開發者也會明確定義一個可選的參數。\n\ncategories:\n    - zh_TW\n---\n\n在許多程式設計語言函數的參數預設值是強制需要的，而開發者也會明確定義一個可選的參數。在 JavaScript 中，每個參數都是可選的，利用 [**es6 參數預設值**](http://exploringjs.com/es6/ch_parameter-handling.html#sec_parameter-default-values)的特性，我們可以強制執行這個行為，而不會弄亂函數的主體。\n\n```javascript\nconst _err = function( message ){\n  throw new Error( message );\n}\n\nconst getSum = (a = _err('a is not defined'), b = _err('b is not defined')) => a + b\n\ngetSum( 10 ) // 拋出錯誤，b 沒有被定義\ngetSum( undefined, 10 ) // 拋出錯誤，a 沒有被定義\n ```\n\n `_err` 是一個函式可以立即拋出錯誤。如果沒有傳送其中一個參數，函數預設值就會被使用，`_err` 將會被呼叫而且會拋出錯誤。你可以在 [Mozilla's Developer Network ](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/default_parameters) 看更多關於 **預設參數值特性** 的範例。\n"},"2016-01-01-angularjs-digest-vs-apply.md":{"name":"2016-01-01-angularjs-digest-vs-apply.md","sha":"c51881823eecf5c8c6e1ecb9ee8f9a5e919ee4d5","content":"---\nlayout: post\n\ntitle: AngularJs - $digest vs $apply\ntip-number: 01\ntip-username: loverajoel\ntip-username-profile: https://github.com/loverajoel\ntip-tldr: JavaScript 模組以及建構步驟變得更多更複雜，但對於新的框架樣板呢？\n\ncategories:\n    - zh_TW\n---\n\nAngularJs 最令人欣賞的特性之一是雙向資料綁定。AngularJS 透過循環方式(`$digest`)來檢查模型和視圖變化來實現這個功能。想要理解框架底層的工作方式，你必須了解這個概念。\n\n當一個事件被觸發時，Angular 會檢查每個 watcher 變化，這是我們所知的 `$digest` 循環。\n有時候你需要強迫手動執行一個新的循環，你必須選擇正確的選項，因為這個階段是最影響效能之一。\n\n### `$apply`\n這個核心方法可以讓你明確地啟動 `$digest` 循環。意思說所有的 watchers 都會被確認；整個應用程式啟動 `$digest loop`。在內部，執行一個可選的功能參數，它會呼叫 `$rootScope.$digest();`。\n\n### `$digest`\n在這個情況下，`$digest` 方法在目前的 scope 和子 scope 啟動 `$digeset` 循環。你應該注意到父 scope 不會被檢查，也不會受影響。\n\n### 建議\n- 當瀏覽器 DOM 事件觸發外部的 AngularJS 使用 `$apply` 或 `$digest`。\n- 傳送一個函式表達式給 `$apply`，這裡有一個錯誤處理機制，並且允許整合所有在 `$digest` 循環的變化。\n\n```javascript\n$scope.$apply(() => {\n\t$scope.tip = 'Javascript Tip';\n});\n```\n\n- 如果你只要更新目前的 scope 和子 scope，使用 `$digest` 防止在整個應用程式執行新的 digest 循環。這在性能上的好處是相當明顯的。\n- `$apply()` 對電腦來說是一個相當複雜的處理程序，如果過多的 binding 會造成性能上的問題。\n- 如果你使用 >AngularJS 1.2.X，使用 `$evalAsync`，這是一個核心方法，可以在目前的循環或下一個循環執行表達式，可以增加你的應用程式效能。\n"},"2016-02-13-know-the-passing-mechanism.md":{"name":"2016-02-13-know-the-passing-mechanism.md","sha":"45a982d7d44e9fd5a9177ff978927970cce70644","content":"---\nlayout: post\n\ntitle: 了解傳送機制\ntip-number: 44\ntip-username: bmkmanoj\ntip-username-profile: https://github.com/bmkmanoj\ntip-tldr: JavaScript 技術上只傳送原始和物件類型的值（或參考）。在參考的類型下，參考值本身是 passed by value。\n\ncategories:\n    - zh_TW\n---\nJavaScript 技術上是透過 pass-by-value。它既不是傳值（pass-by-value）也不是傳參考（pass-by-reference），要理解這些術語的意義，你要了它們傳送的機制，透過以下的範例程式碼和解釋了解它們的意義。\n\n### 範例一\n\n```js\n\nvar me = {\t\t\t\t\t// 1\n\t'partOf' : 'A Team'\n};\n\nfunction myTeam(me) {\t\t// 2\n\n\tme = {\t\t\t\t\t// 3\n\t\t'belongsTo' : 'A Group'\n\t};\n}\n\nmyTeam(me);\nconsole.log(me);\t\t\t// 4  : {'partOf' : 'A Team'}\n\n```\n\n在上方的範例，當 `myTeam` 函式被調用，JavaScript *將 `me` 物件當作 passing the reference 作為值*，調用本身建立了兩個獨立的參考在相同的物件，（雖然在這邊名稱相同，例如 `me`，這是一個誤導讓我們以為它是單一參考物件的印象。），因此，參考變數它們都是獨立的。\n\n當我們在 #`3` 給了一個新的物件，我們完全改變 `myTeam` 函式內的參考值，在函式之外的原始物件不會受到影響，從這裡物件參考到外部保留了原始物件的值，並傳入函式內，因此可以從 #`4` 看到輸出值。\n\n\n### 範例二\n\n```js\n\nvar me = {\t\t\t\t\t// 1\n\t'partOf' : 'A Team'\n};\n\nfunction myGroup(me) { \t\t// 2\n\tme.partOf = 'A Group';  // 3\n}\n\nmyGroup(me);\nconsole.log(me);\t\t\t// 4  : {'partOf' : 'A Group'}\n\n```\n\n在這個例子 `myGroup` 被調用，我們傳送了物件 `me`。但不像範例一的程式碼，我們沒有給予 `me` 變數到任何的新物件，當我們在 `myGroup` 函式內修改物件的屬性，物件參考值一直是參考到原始的值，這是可以有效的改變物件的屬性。因此你可以從 #`7` 看到輸出值。\n\n所以最後一個情況也不能證明 JavaScript 是 pass-by-reference 嗎？不，它不是的。記住，*如果是物件的情況下，JavaScript 將 passes the reference 作為值*。這裡會產生困惑，所以我們往往不能完全理解什麼是傳參考。這是明確的原因，有些人喜歡稱它們為 *call-by-sharing*。\n\n\n*本文最早被作者發表於 [js-by-examples](https://github.com/bmkmanoj/js-by-examples/blob/master/examples/js_pass_by_value_or_reference.md)*\n"},"2016-01-05-differences-between-undefined-and-null.md":{"name":"2016-01-05-differences-between-undefined-and-null.md","sha":"940dcc12d79fffe27b35ed28e1eedcf0c78a8d05","content":"---\nlayout: post\n\ntitle: undefined 和 null 的差別\ntip-number: 05\ntip-username: loverajoel\ntip-username-profile: https://github.com/loverajoel\ntip-tldr: 了解 `undefined` 和 `null` 的差別。\n\ncategories:\n    - zh_TW\n---\n\n- `undefined` 意思是變數沒有被宣告，或者是已經宣告了，但是沒有賦值。\n- `null` 意思是「沒有值」的值。\n- Javascript 將未賦值的變數的預設值設為 `undefined`。\n- Javascript 從來不會將值設定為 `null`。這是讓開發者用來宣告 `var` 是沒有值的。\n- `undefined` 不是一個有效的 JSON，而 `null` 是有效的。\n- `undefined` 的類型（typeof） 是 `undefined`。\n- `null` 的類型（typeof）是一個 `object`。[為什麼？](http://www.2ality.com/2013/10/typeof-null.html)\n- 它們都是原始（primitives）型別。\n- 它們都是 [falsy](https://developer.mozilla.org/en-US/docs/Glossary/Falsy)\n  (`Boolean(undefined) // false`, `Boolean(null) // false`)。\n- 你可以判斷一個變數是否為 [undefined](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined)。\n\n  ```javascript\n  typeof variable === \"undefined\"\n```\n- 你可以判斷一個變數是否為 [null](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null)。\n\n  ```javascript\n  variable === null\n```\n- **雙等號**運算符認為它們是相等的，但是**三等號**比較時是不相等的。\n\n  ```javascript\n  null == undefined // true\n\n  null === undefined // false\n```\n"},"2016-01-07-use-strict-and-get-lazy.md":{"name":"2016-01-07-use-strict-and-get-lazy.md","sha":"12c54164327cf6a28990ae5c969038d73a6d46e3","content":"---\nlayout: post\n\ntitle: 在 JavaScript 使用嚴格模式\ntip-number: 07\ntip-username: nainslie\ntip-username-profile: https://twitter.com/nat5an\ntip-tldr: JavaScript 嚴格模式讓開發者可以寫出更「安全」的 JavaScript 程式碼。\n\ncategories:\n    - zh_TW\n---\n\nJavaScript 嚴格模式讓開發者可以寫出更「安全」的 JavaScript 程式碼。\n\n預設情況下，JavaScript 允許開發者的粗心行為，例如，當我們引用一個沒有要求我們由「var」宣告的變數。或許這個對於一個剛入門的開發者相當方便，當變數名稱拼寫錯誤或者是不小心參考到其他的 scope，這些都是許多錯誤的來源。\n\n開發者喜歡讓電腦幫我們做一些無聊的工作，然後自動幫我們確認工作上的錯誤。這就是 JavaScript 的 「嚴格模式」（use strict）幫我們做的，將錯誤轉換成 JavaScript 錯誤。\n\n我們把這個指令放在 js 檔案的頂端：\n\n```javascript\n// 整個 script 使用嚴格模式\n\"use strict\";\nvar v = \"Hi!  I'm a strict mode script!\";\n```\n\n或是在函式內：\n\n```javascript\nfunction f()\n{\n  // 函式內使用嚴格模式\n  'use strict';\n  function nested() { return \"And so am I!\"; }\n  return \"Hi!  I'm a strict mode function!  \" + nested();\n}\nfunction f2() { return \"I'm not strict.\"; }\n```\n\n透過 JavaScript 檔案或函式內引入這個指令，我們直接讓 JavaScript 引擎執行嚴格模式來禁止一些在大型 JavaScript 專案不良的行為。除了其他之外，嚴格模式改變了以下的行為：\n\n* 只有被宣告的「var」變數才可以被引用。\n* 嘗試寫入唯讀的變數會造成錯誤。\n* 你只能透過「new」keyword 才可以呼叫建構子。\n* 「this」不再隱式的綁定到全域的物件。\n* 對 eval() 有嚴格的限制。\n* 防止你使用保留字元或特殊字元當作變數名稱。\n\n嚴格模式對於你的新專案是很棒的，但是對於引入一些大部分沒有使用舊的專案是一個挑戰。如果你將 js 檔案編譯在一起到你的大項目的話，可能會造成所有的檔案都執行在嚴格模式下，造成一些問題。\n\n它不是一個語法，但它是一個文字上的表達，在早期版本的 JavaScript 被忽略了。\n嚴格模式支援以下：\n\n* Internet Explorer from version 10.\n* Firefox from version 4.\n* Chrome from version 13.\n* Safari from version 5.1.\n* Opera from version 12.\n\n[嚴格模式的詳細說明，請參考 MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode)。\n"},"2016-01-27-short-circiut-evaluation-in-js.md":{"name":"2016-01-27-short-circiut-evaluation-in-js.md","sha":"7aef864df024d91a88ffe7e23f59bfc1ea6165c8","content":"---\nlayout: post\n\ntitle: JavaScript 中的捷徑計算\ntip-number: 27\ntip-username: bhaskarmelkani\ntip-username-profile: https://www.twitter.com/bhaskarmelkani\ntip-tldr: 捷徑計算意思是說，假設第一個參數不足以確定表達式的值，第二個參數才會被執行，當 AND 函數的第一個參數計算結果為 false，則所有結果則為 false；當 OR 函數的第一個參數計算結果為 true，則所有結果為 true。\n\ncategories:\n    - zh_TW\n---\n\n[捷徑計算](https://en.wikipedia.org/wiki/Short-circuit_evaluation)意思是說，假設第一個參數不足以確定表達式的值，第二個參數才會被執行，當 AND 函數的第一個參數計算結果為 false，則所有結果則為 false；當 OR 函數的第一個參數計算結果為 true，則所有結果為 true。\n\n對於以下的 `test` 條件和 `isTrue` 以及 `isFalse` 函式。\n\n```js\nvar test = true;\nvar isTrue = function(){\n  console.log('Test is true.');\n};\nvar isFalse = function(){\n  console.log('Test is false.');\n};\n\n```\n使用 AND 邏輯 - `&&`。\n\n```js\n// 一個正常的 if 條件式\nif (test){\n  isTrue();    // Test 是 true\n}\n\n// 上面可以使用 '&&' 作為 -\n\n( test && isTrue() );  // Test 是 true\n```\n使用 OR 邏輯 - `||`。\n\n```js\ntest = false;\nif (!test){\n  isFalse();    // Test 是 false.\n}\n\n( test || isFalse());  // Test 是 false.\n```\nOR 邏輯可以用在為函式參數設定預設值。\n\n```js\nfunction theSameOldFoo(name){\n    name = name || 'Bar' ;\n    console.log(\"My best friend's name is \" + name);\n}\ntheSameOldFoo();  // My best friend's name is Bar\ntheSameOldFoo('Bhaskar');  // My best friend's name is Bhaskar\n```\n當屬性尚未被定義的時候，邏輯 AND 可以避免異常情況。\n例如：\n\n```js\nvar dog = {\n  bark: function(){\n     console.log('Woof Woof');\n   }\n};\n\n// 呼叫 dog.bark();\ndog.bark(); // Woof Woof.\n\n// 但是如果 dog 尚未被定義，dog.bark() 將會發生「無法讀取尚未定義的屬性 'bark'」的錯誤。\n// 為了防止這個問題，我們使用 &&。\n\ndog && dog.bark(); // 如果 dog 被定義了，那我們就可以呼叫 dog.bark()。\n\n```\n"},"2016-01-28-curry-vs-partial-application.md":{"name":"2016-01-28-curry-vs-partial-application.md","sha":"016975d030ba8e17c6b0a412f5cce873e3b35c5f","content":"---\nlayout: post\n\ntitle: 柯里化（currying）和部分應用程式\ntip-number: 28\ntip-username: bhaskarmelkani\ntip-username-profile: https://www.twitter.com/bhaskarmelkani\ntip-tldr: 柯里化（currying）和部分應用程式（partial application）是將函式轉換成一般較小的 arity 和另一個函式的兩種方式。\n\n\ncategories:\n    - zh_TW\n---\n\n**柯里化**\n\n柯里化是將一個函式\n\n`f: X * Y -> R`\n\n轉換成\n\n`f': X -> (Y -> R)`\n\n而不是帶有兩個參數的 `f'`，我們調用 `f'` 與第一個參數。其結果是一個函式，我們可以呼叫第二個參數來產生結果。\n\n因此，未使用柯里化的函式 `f` 像這樣調用：\n\n`f(3, 5)`\n\n如果使用柯里化後的函式 `f'` 像這樣調用：\n\n`f(3)(5)`\n\n例如：\n尚未柯里化的函式 `add()`\n\n```javascript\n\nfunction add(x, y) {\n  return x + y;\n}\n\nadd(3, 5);   // returns 8\n```\n\n柯里化後的函式 `add()`\n\n```javascript\nfunction addC(x) {\n  return function (y) {\n    return x + y;\n  }\n}\n\naddC(3)(5);   // returns 8\n```\n\n**柯里化的規則**\n\n柯里化將一個二元函式轉換成一個一元函式，這個一元函式再回傳一個一元函式。\n\n柯里化：`(X × Y → R) → (X → (Y → R))`\n\nJavaScript 程式碼：\n\n```javascript\nfunction curry(f) {\n  return function(x) {\n    return function(y) {\n      return f(x, y);\n    }\n  }\n}\n```\n\n**部分應用程式**\n\n部分應用程式將一個函式的\n\nf：`X * Y -> R`\n\n第一個參數固定來產生新的函式\n\nf'：`Y -> R`\n\n`f'` 和 `f` 不同，只需要填寫第二個參數，這也是為什麼 `f'` 比 `f` 少一個參數的原因。\n\n例如：綁定函式的第一個參數來產生函式 `plus5`。\n\n```javascript\nfunction plus5(y) {\n  return 5 + y;\n}\n\nplus5(3);  // returns 8\n```\n\n**部分應用程式的規則**\n\n部分應用程式將二元函式和數值產生一個一元函式。\n\n部分應用程式: `((X × Y → R) × X) → (Y → R)`\n\nJavascript 程式碼：\n\n```javascript\nfunction partApply(f, x) {\n  return function(y) {\n    return f(x, y);\n  }\n}\n```\n"},"2016-01-25-Using-immediately-invoked-function-expression.md":{"name":"2016-01-25-Using-immediately-invoked-function-expression.md","sha":"9d9a5be662846ba54605ffa0b812d0b5b7cbd025","content":"---\nlayout: post\n\ntitle: 使用立即函式表達式\ntip-number: 25\ntip-username: rishantagarwal\ntip-username-profile: https://github.com/rishantagarwal\ntip-tldr: 稱作「Iffy」（IIFE - immediately invoked function expression）是一個匿名函式表達式，而且可以立即被調用，在 JavaScript 中有一些相當重要的用途。\n\n\ncategories:\n    - zh_TW\n---\n\n稱作「Iffy」（IIFE - immediately invoked function expression）是一個匿名函式表達式，而且可以立即被調用，在 JavaScript 中有一些相當重要的用途。\n\n```javascript\n\n(function() {\n // Do something​\n }\n)()\n\n```\n\n它是一個匿名函式表達式，而且可以立即被調用，在 JavaScript 某些部分中相當重要。\n\n一對括號包著匿名函式，將匿名函式變成函式表達式或變數表達式。我們現在有一個未命名的函式表達式，它不是一個在全域 scope 內的簡單匿名函式或者是其他任何被定義的函式。\n\n同樣的，我們也可以為立即函式表達式命名：\n\n```javascript\n(someNamedFunction = function(msg) {\n    console.log(msg || \"Nothing for today !!\")\n})(); // 輸出 --> Nothing for today !!​\n​\nsomeNamedFunction(\"Javascript rocks !!\"); // 輸出 --> Javascript rocks !!\nsomeNamedFunction(); // 輸出 --> Nothing for today !!​\n```\n\n更多細節，請參考以下網址 -\n1. [連結一](https://blog.mariusschulz.com/2016/01/13/disassembling-javascripts-iife-syntax)\n2. [連結二](http://javascriptissexy.com/12-simple-yet-powerful-javascript-tips/)\n\n效能：\n[jsPerf](http://jsperf.com/iife-with-call)\n"},"2016-02-17-reminders-about-reduce-function-usage.md":{"name":"2016-02-17-reminders-about-reduce-function-usage.md","sha":"a21b4d50554648cb186fe9427f2d0b3f7a48dcce","content":"---\nlayout: post\n\ntitle: 如何 reduce 陣列\ntip-number: 48\ntip-username: darul75\ntip-username-profile: https://twitter.com/darul75\ntip-tldr: 有關使用 `reduce` 函式的一些提醒。\n\ncategories:\n    - zh_TW\n---\n\n正如官方文件所寫的，`reduce()` 方法接收一個函式做為累加器（accumulator），陣列中的每個值（由左到右）將會合併，最後只得到一個值。\n\n### 署名\n\n[reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce) 函式接受 2 個參數（M：強制的，O：可選的）：\n\n- (M) 一個 callback **reducer 函式** 可以處理先前的計算結果，到下一個元素直到最後。\n- (O) 一個**初始值**可以被當作第一個呼叫 callback 的第一個參數。\n\n所以讓我們來看一下普遍的用法，之後再看更多的複雜的用法。\n\n### 普遍用法（累加、關聯）\n\n我們在逛 Amazon 網站（價格為美元），但是我們的 caddy 太滿了，所以讓我們計算總價。\n\n```javascript\n// 我目前在 amazon 購買的 caddy\nvar items = [{price: 10}, {price: 120}, {price: 1000}];\n\n// 我們的 reducer 函式\nvar reducer = function add(sumSoFar, item) { return sumSoFar + item.price; };\n\n// 計算結果\nvar total = items.reduce(reducer, 0);\n\nconsole.log(total); // 1130\n```\n\n我們在第一個事件，我們提供了 `reduce` 可選函式參數為一個整數 0，可以是一個物件、或是一個陣列，而不是原始的類型，之後我們將會看到。\n\n現在，太酷了我得到一個 20$ 的折價券。\n\n```javascript\nvar total = items.reduce(reducer, -20);\n\nconsole.log(total); // 1110\n```\n\n### 進階用法（組合）\n\n第二個使用範例的靈感是來自 Redux 的 [combineReducers](http://redux.js.org/docs/api/combineReducers.html) 函式，[原始碼](https://github.com/reactjs/redux/blob/master/src/combineReducers.js#L93)。\n\n背後的想法是將 reducer 函式拆成獨立的函式，然後在最後計算出一個新的*單一 reducer 函式*。\n\n如果要說明這些，讓我們建立一個單一物件和一些 reducers 函式可以計算不同的貨幣（$、€...）的總價。\n\n```javascript\nvar reducers = {\n  totalInDollar: function(state, item) {\n    // 具體宣告...\n    return state.dollars += item.price;\n  },\n  totalInEuros : function(state, item) {\n    state.euros += item.price * 0.897424392;\n    return state;\n  },\n  totalInPounds : function(state, item) {\n    state.pounds += item.price * 0.692688671;\n    return state;\n  },\n  totalInYen : function(state, item) {\n    state.yens += item.price * 113.852;\n    return state;\n  }\n  // 更多...\n};\n```\n\n然後，我們建立一個新的多功能函式\n\n- 負責應用每個部分的 reduce 函式。\n- 回傳一個新的 callback reducer 函式。\n\n```javascript\nvar combineTotalPriceReducers = function(reducers) {\n  return function(state, item) {\n    return Object.keys(reducers).reduce(\n      function(nextState, key) {\n        reducers[key](state, item);\n        return state;\n      },\n      {}\n    );\n  }\n};\n```\n\n現在讓我們看看如何使用它。\n\n```javascript\nvar bigTotalPriceReducer = combineTotalPriceReducers(reducers);\n\nvar initialState = {dollars: 0, euros:0, yens: 0, pounds: 0};\n\nvar totals = items.reduce(bigTotalPriceReducer, initialState);\n\nconsole.log(totals);\n\n/*\nObject {dollars: 1130, euros: 1015.11531904, yens: 127524.24, pounds: 785.81131152}\n*/\n```\n\n\n我希望這種方法可以給你使用 reduce() 函數的時候提供另一個想法。\n\n你的 reduce 函式可以處理每個計算的歷史記錄。這個在 Ramdajs 的 [scan](http://ramdajs.com/docs/#scan) 函式已經實現了。\n\n[在 JSFiddle 試試看](https://jsfiddle.net/darul75/81tgt0cd/)\n"},"2016-01-08-converting-a-node-list-to-an-array.md":{"name":"2016-01-08-converting-a-node-list-to-an-array.md","sha":"00b6741f5296e9edb93c5e5b51a5fee562b3a919","content":"---\nlayout: post\n\ntitle: 將 Node List 轉換成陣列\ntip-number: 08\ntip-username: Tevko\ntip-username-profile: https://twitter.com/tevko\ntip-tldr: 這是快速，安全，可重複使用的方式，將 Node List 轉換成 DOM 元素的陣列。\n\ncategories:\n    - zh_TW\n---\n\n`querySelectorAll` 方法回傳一個類似陣列的物件稱為 Node List。這些資料結構簡稱為「類陣列」，因為他們和陣列很相似，但是不能使用陣列的方法像是 `map` 和 `forEach`。這是快速，安全，可重複使用的方式，將 Node List 轉換成 DOM 元素的陣列：\n\n```javascript\nconst nodelist = document.querySelectorAll('div');\nconst nodelistToArray = Array.apply(null, nodelist);\n\n// 之後 ..\n\nnodelistToArray.forEach(...);\nnodelistToArray.map(...);\nnodelistToArray.slice(...);\n\n// 等等...\n```\n\n`apply` 方法將參數陣列傳送給一個函式與給定 this 的值。根據 [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply) ，`apply` 採用類陣列物件，而這剛好就是 `querySelectorAll` 方法所回傳的內容。如果我們不需要在函式的上下文（context）中指定 `this` ，我們可以傳送 `null` 或 `0`。這個結果實際上是一個 DOM 元素陣列，包含所有可用的陣列方法。\n\n或者，假設你使用 ES2015 你可以使用[展開運算符 `...`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator)。\n\n```js\nconst nodelist = [...document.querySelectorAll('div')]; // 回傳一個實際的陣列\n\n// 之後 ..\n\nnodelist.forEach(...);\nnodelist.map(...);\nnodelist.slice(...);\n\n// 等等...\n```\n"},"2016-01-26-filtering-and-sorting-a-list-of-strings.md":{"name":"2016-01-26-filtering-and-sorting-a-list-of-strings.md","sha":"6ae32527644adef2110c7bd4d81c1326f9d28a50","content":"---\nlayout: post\n\ntitle: 過濾和排序字串清單\ntip-number: 26\ntip-username: davegomez\ntip-username-profile: https://github.com/davegomez\ntip-tldr: 你可能有一份很大的清單，而你需要過濾重複的內容並移除，再依字母排序。\n\ncategories:\n    - zh_TW\n---\n\n你可能有一份很大的清單，而你需要過濾重複的內容並移除，再依字母排序。\n\n在我們的範例，我使用了不同版本的 **JavaScript 保留字元** 的清單，但你要注意到，這裡有一些重複的字元而且他們不是依字母排序的。所以，這裡有一個相當棒的字串[陣列](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)清單來測試這個 JavaScript tip。\n\n```js\nvar keywords = ['do', 'if', 'in', 'for', 'new', 'try', 'var', 'case', 'else', 'enum', 'null', 'this', 'true', 'void', 'with', 'break', 'catch', 'class', 'const', 'false', 'super', 'throw', 'while', 'delete', 'export', 'import', 'return', 'switch', 'typeof', 'default', 'extends', 'finally', 'continue', 'debugger', 'function', 'do', 'if', 'in', 'for', 'int', 'new', 'try', 'var', 'byte', 'case', 'char', 'else', 'enum', 'goto', 'long', 'null', 'this', 'true', 'void', 'with', 'break', 'catch', 'class', 'const', 'false', 'final', 'float', 'short', 'super', 'throw', 'while', 'delete', 'double', 'export', 'import', 'native', 'public', 'return', 'static', 'switch', 'throws', 'typeof', 'boolean', 'default', 'extends', 'finally', 'package', 'private', 'abstract', 'continue', 'debugger', 'function', 'volatile', 'interface', 'protected', 'transient', 'implements', 'instanceof', 'synchronized', 'do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case', 'else', 'enum', 'eval', 'null', 'this', 'true', 'void', 'with', 'break', 'catch', 'class', 'const', 'false', 'super', 'throw', 'while', 'yield', 'delete', 'export', 'import', 'public', 'return', 'static', 'switch', 'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue', 'debugger', 'function', 'arguments', 'interface', 'protected', 'implements', 'instanceof', 'do', 'if', 'in', 'for', 'let', 'new', 'try', 'var', 'case', 'else', 'enum', 'eval', 'null', 'this', 'true', 'void', 'with', 'await', 'break', 'catch', 'class', 'const', 'false', 'super', 'throw', 'while', 'yield', 'delete', 'export', 'import', 'public', 'return', 'static', 'switch', 'typeof', 'default', 'extends', 'finally', 'package', 'private', 'continue', 'debugger', 'function', 'arguments', 'interface', 'protected', 'implements', 'instanceof'];\n```\n\n因為我們不想改變我們原有的清單，所以我們使用高階函式叫做 [`filter`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)，它會基於我們傳送的陣列（*函式*）並回傳一個過濾後的新陣列。基於目前的清單和新的清單索引 `index` 的比較，會把和 index 相符的元素 push 到新陣列成為新的清單。\n\n最後，我們使用 [`sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort) 函式來排序過濾後的結果，將比較函式當作唯一的參數，回傳依字母排序後的清單。\n\n```js\nvar filteredAndSortedKeywords = keywords\n  .filter(function (keyword, index) {\n      return keywords.indexOf(keyword) === index;\n    })\n  .sort(function (a, b) {\n      if (a < b) return -1;\n      else if (a > b) return 1;\n      return 0;\n});\n```\n\n使用 **ES6**（ECMAScript 2015）版本的[箭頭函式](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions)看起來更簡潔：\n\n```js\nconst filteredAndSortedKeywords = keywords\n  .filter((keyword, index) => keywords.indexOf(keyword) === index)\n  .sort((a, b) => {\n      if (a < b) return -1;\n      else if (a > b) return 1;\n      return 0;\n    });\n```\n\n這是最後過濾以及排序後的 JavaScript 保留字元清單：\n\n```js\nconsole.log(filteredAndSortedKeywords);\n\n// ['abstract', 'arguments', 'await', 'boolean', 'break', 'byte', 'case', 'catch', 'char', 'class', 'const', 'continue', 'debugger', 'default', 'delete', 'do', 'double', 'else', 'enum', 'eval', 'export', 'extends', 'false', 'final', 'finally', 'float', 'for', 'function', 'goto', 'if', 'implements', 'import', 'in', 'instanceof', 'int', 'interface', 'let', 'long', 'native', 'new', 'null', 'package', 'private', 'protected', 'public', 'return', 'short', 'static', 'super', 'switch', 'synchronized', 'this', 'throw', 'throws', 'transient', 'true', 'try', 'typeof', 'var', 'void', 'volatile', 'while', 'with', 'yield']\n```\n"},"2016-01-20-return-objects-to-enable-chaining-of-functions.md":{"name":"2016-01-20-return-objects-to-enable-chaining-of-functions.md","sha":"bd50601add8f8b5706e555c14371715cf1eaa7bd","content":"---\nlayout: post\n\ntitle: 回傳物件並使用函式鏈結\ntip-number: 20\ntip-username: WakeskaterX\ntip-username-profile: https://twitter.com/WakeStudio\ntip-tldr: 在 JavaScript 物件導向中，我們在物件上建立函式，函式回傳的物件讓你可以將函式鏈結在一起。\n\ncategories:\n    - zh_TW\n---\n\n在 JavaScript 物件導向中，我們在物件上建立函式，函式回傳的物件讓你可以將函式鏈結在一起。\n\n```js\nfunction Person(name) {\n  this.name = name;\n\n  this.sayName = function() {\n    console.log(\"Hello my name is: \", this.name);\n    return this;\n  };\n\n  this.changeName = function(name) {\n    this.name = name;\n    return this;\n  };\n}\n\nvar person = new Person(\"John\");\nperson.sayName().changeName(\"Timmy\").sayName();\n```\n"},"2016-02-11-preventing-unapply-attacks.md":{"name":"2016-02-11-preventing-unapply-attacks.md","sha":"bbb5d6149e6ee696388618b9f7a06b778cf5d318","content":"---\nlayout: post\n\ntitle: 防止 Unapply 攻擊\ntip-number: 42\ntip-username: emars\ntip-username-profile: https://twitter.com/marseltov\ntip-tldr: 凍結內建的屬性。\n\ncategories:\n    - zh_TW\n---\n\n透過覆寫內建的原型，攻擊者可以重寫程式碼來暴露或更改綁定的參數。這是一個嚴重的安全漏洞，利用 es5 polyfill 的方法。\n\n```js\n// 綁定 polyfill 範例\nfunction bind(fn) {\n  var prev = Array.prototype.slice.call(arguments, 1);\n  return function bound() {\n    var curr = Array.prototype.slice.call(arguments, 0);\n    var args = Array.prototype.concat.apply(prev, curr);\n    return fn.apply(null, args);\n  };\n}\n\n\n// unapply 攻擊\nfunction unapplyAttack() {\n  var concat = Array.prototype.concat;\n  Array.prototype.concat = function replaceAll() {\n    Array.prototype.concat = concat; // 恢復正確的版本\n    var curr = Array.prototype.slice.call(arguments, 0);\n    var result = concat.apply([], curr);\n    return result;\n  };\n}\n```\n\n以上的函式拋棄了綁定的 `prev` 陣列，任何 `.concat` 在第一個 `concat` 被呼叫之後使用 unapply 攻擊會拋出錯誤。\n\n使用 [Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze) 讓物件保持不變，你可以防止任何內建物件原型被覆寫。\n\n\n```js\n(function freezePrototypes() {\n  if (typeof Object.freeze !== 'function') {\n    throw new Error('Missing Object.freeze');\n  }\n  Object.freeze(Object.prototype);\n  Object.freeze(Array.prototype);\n  Object.freeze(Function.prototype);\n}());\n```\n\n你可以在[這裡](https://glebbahmutov.com/blog/unapply-attack/)閱讀更多關於 unapply 攻擊。\n"},"2016-01-15-even-simpler-way-of-using-indexof-as-a-contains-clause.md":{"name":"2016-01-15-even-simpler-way-of-using-indexof-as-a-contains-clause.md","sha":"f5fd6fdf6428a3e2590bdf5e4a15865065c194d6","content":"---\nlayout: post\n\ntitle: 更簡單的方式將 indexOf 當作 contains 使用\ntip-number: 15\ntip-username: jhogoforbroke\ntip-username-profile: https://twitter.com/jhogoforbroke\ntip-tldr: JavaScript 預設沒有 contain 的方法。如果要檢查字串或是陣列內是否有子字串的存在你可以這樣做。\n\ncategories:\n    - zh_TW\n---\n\nJavaScript 預設沒有 contain 的方法。如果要檢查字串或是陣列內是否有子字串的存在你可以這樣做：\n\n```javascript\nvar someText = 'javascript rules';\nif (someText.indexOf('javascript') !== -1) {\n}\n\n// or\nif (someText.indexOf('javascript') >= 0) {\n}\n```\n\n但是，讓我看一下這些 [Expressjs](https://github.com/strongloop/express) 程式碼片段。\n\n[examples/mvc/lib/boot.js](https://github.com/strongloop/express/blob/2f8ac6726fa20ab5b4a05c112c886752868ac8ce/examples/mvc/lib/boot.js#L26)\n\n\n```javascript\nfor (var key in obj) {\n  // \"reserved\" exports\n  if (~['name', 'prefix', 'engine', 'before'].indexOf(key)) continue;\n```\n\n[lib/utils.js](https://github.com/strongloop/express/blob/2f8ac6726fa20ab5b4a05c112c886752868ac8ce/lib/utils.js#L93)\n\n\n```javascript\nexports.normalizeType = function(type){\n  return ~type.indexOf('/')\n    ? acceptParams(type)\n    : { value: mime.lookup(type), params: {} };\n};\n```\n\n[examples/web-service/index.js](https://github.com/strongloop/express/blob/2f8ac6726fa20ab5b4a05c112c886752868ac8ce/examples/web-service/index.js#L35)\n\n\n```javascript\n// key 是無效的\nif (!~apiKeys.indexOf(key)) return next(error(401, 'invalid api key'));\n```\n\n困難的地方是[位元運算符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators) **~**，「位元運算符在二進制執行它們的操作，但是它們回傳的是標準 JavaScript 數值」。\n\n它將 `-1` 轉換成 `0`，而 `0` 在 JavaScript 當作 `false`：\n\n```javascript\nvar someText = 'text';\n!!~someText.indexOf('tex'); // someText 包含 \"tex\" - true\n!~someText.indexOf('tex'); // someText 不包含 \"tex\" - false\n~someText.indexOf('asd'); // someText 不包含 \"asd\" - false\n~someText.indexOf('ext'); // someText 包含 \"ext\" - true\n```\n\n### String.prototype.includes()\n\nES6 提供了 [includes() 方法](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes)，你可以使用它來判斷字串是否包含在其他字串：\n\n```javascript\n'something'.includes('thing'); // true\n```\n\n在 ECMAScript 2016（ES7）中，在陣列甚至有可能可以使用這些方法：\n\n```javascript\n!!~[1, 2, 3].indexOf(1); // true\n[1, 2, 3].includes(1); // true\n```\n\n**不幸的是，這只支援在 Chrome、Firefox、Safari 9 或是更高版本的 Edge；在 IE11 或更低版本則無法使用。**\n**它最好在被控制的環境下使用。**\n"},"2016-02-02-create-range-0...n-easily-using-one-line.md":{"name":"2016-02-02-create-range-0...n-easily-using-one-line.md","sha":"92499c404fa40625aa08315cdbc7b63a8f4afc80","content":"---\nlayout: post\n\ntitle: 使用一行程式碼簡單建立一個 0...(N - 1) 的陣列\ntip-number: 33\ntip-username: SarjuHansaliya\ntip-username-profile: https://github.com/SarjuHansaliya\ntip-tldr: 我們透過一行程式碼簡單建立一個範圍函式，它可以給定一個 0...(N - 1) 的範圍。\n\n\ncategories:\n    - zh_TW\n---\n\n使用下方的程式碼，我們可以建立一個 0...(N - 1) 的陣列。\n\n```js\nArray.apply(null, {length: N}).map(Number.call, Number);\n```\n\n讓我們來拆解這行程式碼。我們知道 `call` 函式可以在 JavaScript 執行。所以，在 `call` 第一個參數是上下文（context），而第二個參數開始則是呼叫 `call` 函式所需要用到的參數。\n\n```js\nfunction add(a, b){\n    return (a + b);\n}\nadd.call(null, 5, 6);\n```\n回傳 5 和 6 的總和。\n\n在 JavaScript 陣列的 `map()` 帶有兩個參數，第一個是 `callback`，第二個則是 `thisArg(context)`。`callback` 中帶有三個參數，`value`、`index` 以及整個要被迭代的陣列。常見的語法像是這樣：\n\n```js\n[1, 2, 3].map(function(value, index, arr){\n    // 程式碼\n}, this);\n```\n以下程式碼建立特定長度的陣列。\n\n```js\nArray.apply(null, {length: N})\n```\n把所有部分組合一起就是如下的解決方法。\n\n```js\nArray.apply(null, {length: N}).map(Number.call, Number);\n```\n\n如果你想要 1...N 的範圍，你可以像這樣。\n\n```js\nArray.apply(null, {length: N}).map(function(value, index){\n  return index + 1;\n});\n```\n"},"2016-02-12-use-destructuring-in-function-parameters.md":{"name":"2016-02-12-use-destructuring-in-function-parameters.md","sha":"6571d677115d6e2a55cc89ba35ce8d126d929687","content":"---\nlayout: post\n\ntitle: 在函式參數裡使用解構子\ntip-number: 43\ntip-username: dislick\ntip-username-profile: https://github.com/dislick\ntip-tldr: 你知道可以在函式的參數裡使用解構子嗎？\n\ncategories:\n    - zh_TW\n---\n我相信很多人都已經很熟悉 [ES6 解構賦值](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment)。你知道也可以用在函式的參數裡嗎？\n\n```javascript\nvar sayHello = function({ name, surname }) {\n  console.log(`Hello ${name} ${surname}! How are you?`);\n};\n\nsayHello({\n  name: 'John',\n  surname: 'Smith'\n});\n```\n\n這對函式接受一個可選的物件是相當有用的。\n\n> 請注意解構賦值現在 Node.js 還有其他瀏覽器還無法使用。如果你想要試試看的話，你可以在 Node.js 使用 `--harmony-destructuring`。\n"},"2016-02-03-implementing-asynchronous-loops.md":{"name":"2016-02-03-implementing-asynchronous-loops.md","sha":"9428ce558f085c5fcdcbcc4d3442a67f8133e91f","content":"---\nlayout: post\n\ntitle: 實作非同步迴圈\ntip-number: 34\ntip-username: madmantalking\ntip-username-profile: https://github.com/madmantalking\ntip-tldr: 你或許可以實作非同步迴圈，但是執行時可能會遇到問題。\n\ncategories:\n    - zh_TW\n---\n\n讓我們嘗試撰寫一個非同步的函式，在每秒列印出迴圈的索引值。\n\n```js\nfor (var i = 0; i < 5; i++) {\n\tsetTimeout(function(){\n\t\tconsole.log(i);\n\t}, 1000 * (i + 1));\n}\n```\n上面的程式將會輸出以下的結果：\n\n```js\n> 5\n> 5\n> 5\n> 5\n> 5\n```\n所以這肯定是不能執行的。\n\n**原因**\n\n每個 timeout 指向到原來的 `i`，而非拷貝的。所以在迴圈下 `i` 會增加直到 5，然後 timeout 執行並使用目前的 `i` 數值（i 是 5）。\n\n當然，這個問題看似簡單。一個直接的解決方法就是將迴圈的索引暫存到變數。\n\n```js\nfor (var i = 0; i < 5; i++) {\n\tvar temp = i;\n \tsetTimeout(function(){\n\t\tconsole.log(temp);\n\t}, 1000 * (i + 1));\n}\n```\n但以上的程式輸出的結果是：\n\n```js\n> 4\n> 4\n> 4\n> 4\n> 4\n```\n\n所以，一樣不能執行，因為區塊初始化時沒有建立一個範圍和變數，把它們提升到 scope 的頂部。事實上，在前面的程式碼也是相同的：\n\n```js\nvar temp;\nfor (var i = 0; i < 5; i++) {\n \ttemp = i;\n\tsetTimeout(function(){\n\t\tconsole.log(temp);\n  \t}, 1000 * (i + 1));\n}\n```\n**解決辦法**\n\n這裡有一些不同的方式來複製 `i`。一般的方式是建立一個 closure，宣告一個函式並將 `i` 作為一個參數傳送。在這裡我們做了一個立即函式。\n\n```js\nfor (var i = 0; i < 5; i++) {\n\t(function(num){\n\t\tsetTimeout(function(){\n\t\t\tconsole.log(num);\n\t\t}, 1000 * (i + 1));\n\t})(i);\n}\n```\n在 JavaScript，參數是透過傳值方式給函數。所以原始的類型像是數字、日期、和字串基本上都是被複製的。如果你想要再函式內改變他們，它是不會影響外部的範圍。物件比較特別：假設內部函數改變屬性，這個改變會影響所有範圍。\n\n其他解決方法可以使用 `let`。它是 `ES6` 其中一種變數的宣告方式，它和 `var` 不一樣，只在區塊內作用。\n\n```js\nfor (let i = 0; i < 5; i++) {\n\tvar temp = i;\n \tsetTimeout(function(){\n\t\tconsole.log(temp);\n\t}, 1000 * (i + 1));\n}\n```\n"},"2016-01-14-fat-arrow-functions.md":{"name":"2016-01-14-fat-arrow-functions.md","sha":"00aa6182e2b646096d13567afda1d2cddf160cec","content":"---\nlayout: post\n\ntitle: 箭頭函式\ntip-number: 14\ntip-username: pklinger\ntip-username-profile: https://github.com/pklinger/\ntip-tldr: 介紹一個 ES6 的新特性 - 箭頭函式是一個方便的語法讓你用更少的程式碼做更多事。\n\ncategories:\n    - zh_TW\n---\n\n介紹一個 ES6 的新特性 - 箭頭函式，它是一個方便的語法讓你用更少的程式碼做更多事。它的名稱來自它的語法，`=>`，它是一個「fat arrow」， 相較於 `->`。有些開發者或許已經知道這個類型的函式是從不同的程式語言來的，像是 Haskell，作為「lambda 表達式」或者是「匿名函式」。它被稱作匿名函式是因為沒有一個名稱作為函數的名稱。\n\n### 這有什麼好處？\n* 語法：更少的程式碼；不需要重複再打出 `function`。\n* 語義：從上下文（contex）取得 `this`。\n\n### 簡單的語法範例\n你可以觀察這兩個程式碼的片段，它們做的是相同的工作，你很快地可以了解到箭頭函式做了什麼：\n\n```javascript\n// 箭頭函式的一般語法\nparam => expression\n\n// 也可以寫入括號\n// 在多個參數時，括號是必須的\n(param1 [, param2]) => expression\n\n\n// 使用函式\nvar arr = [5,3,2,9,1];\nvar arrFunc = arr.map(function(x) {\n  return x * x;\n});\nconsole.log(arr)\n\n// 使用箭頭函式\nvar arr = [5,3,2,9,1];\nvar arrFunc = arr.map((x) => x*x);\nconsole.log(arr)\n```\n\n正如你所見的，在這個範例箭頭函式省去了打出函式的括號和 return。我建議你在參數周圍寫出小括號，如果你需要多個輸入參數，像是 `(x, y) => x + y`。這是一個用來應付在不同情況下忘記使用小括號的方法。上面的程式碼也是這樣執行的：`x => x * x`。到目前為止，這些只是語法上的改進，減少的程式碼以及提高可讀性。\n\n### 詞彙綁定 - `this`\n\n這是一個另一個更棒的理由來使用箭頭函式。這裡有一個 `this` context 的問題。使用箭頭函數，你不需要擔心 `.bind(this)` 或設定 `that = this` 的問題了，在箭頭函式會幫你從詞彙的範圍綁定 `this` 的 context。看以下的[範例](https://jsfiddle.net/pklinger/rw94oc11/)：\n\n```javascript\n\n// 在全域定義 this.i\nthis.i = 100;\n\nvar counterA = new CounterA();\nvar counterB = new CounterB();\nvar counterC = new CounterC();\nvar counterD = new CounterD();\n\n// bad example\nfunction CounterA() {\n  // CounterA 的 `this` 實例（！！這裡被忽略了）\n  this.i = 0;\n  setInterval(function () {\n    // `this` 參考到全域的物件，而不是 CounterA's 的 `this`，\n    // 因此，起始的計數是 100，而不是 0（CounterA 的 this.i）。\n    this.i++;\n    document.getElementById(\"counterA\").innerHTML = this.i;\n  }, 500);\n}\n\n// 手動綁定 that = this\nfunction CounterB() {\n  this.i = 0;\n  var that = this;\n  setInterval(function() {\n    that.i++;\n    document.getElementById(\"counterB\").innerHTML = that.i;\n  }, 500);\n}\n\n// 使用 .bind(this)\nfunction CounterC() {\n  this.i = 0;\n  setInterval(function() {\n    this.i++;\n    document.getElementById(\"counterC\").innerHTML = this.i;\n  }.bind(this), 500);\n}\n\n// 箭頭函式\nfunction CounterD() {\n  this.i = 0;\n  setInterval(() => {\n    this.i++;\n    document.getElementById(\"counterD\").innerHTML = this.i;\n  }, 500);\n}\n```\n\n更多關於箭頭函式的資訊你可以在 [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions) 找到。如果查看不同的語法選項拜訪[這個網站](http://jsrocks.org/2014/10/arrow-functions-and-their-scope/)。\n"},"2016-02-01-map-to-the-rescue-adding-order-to-object-properties.md":{"name":"2016-02-01-map-to-the-rescue-adding-order-to-object-properties.md","sha":"773ba1b7c2030a01f8ad8abe7ad5e0e51fc77832","content":"---\nlayout: post\n\ntitle: 透過 Map() 在你的物件屬性加入排序\ntip-number: 32\ntip-username: loverajoel\ntip-username-profile: https://twitter.com/loverajoel\ntip-tldr: 物件是一個沒有排序的屬性集合...意思說，如果你想嘗試在你的物件儲存已排序的資料，你需要重新檢查，因為屬性在物件不保證是有排序的。\n\ncategories:\n    - zh_TW\n---\n\n## 物件屬性的順序\n\n> 一個物件是一個 `Object` 的類型。它是包含原始值、物件、或是函式這些尚未排序屬性的集合。一個物件的屬性儲存了一個函式稱為方法。 [ECMAScript](http://www.ecma-international.org/publications/files/ECMA-ST-ARCH/ECMA-262,%203rd%20edition,%20December%201999.pdf)\n\n實際看一下範例\n\n```js\nvar myObject = {\n\tz: 1,\n\t'@': 2,\n\tb: 3,\n\t1: 4,\n\t5: 5\n};\nconsole.log(myObject) // Object {1: 4, 5: 5, z: 1, @: 2, b: 3}\n\nfor (item in myObject) {...\n// 1\n// 5\n// z\n// @\n// b\n```\n因為每個瀏覽器有自己排序物件的規則，所以順序是不確定的。\n\n## 要如何解決這個問題？\n\n### Map\n\n使用 ES6 的新特性 - Map。[Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) 物件迭代元素插入的順序。`for...of` 迴圈每次迭代回傳一個 [key, value] 的陣列。\n\n```js\nvar myObject = new Map();\nmyObject.set('z', 1);\nmyObject.set('@', 2);\nmyObject.set('b', 3);\nfor (var [key, value] of myObject) {\n  console.log(key, value);\n...\n// z 1\n// @ 2\n// b 3\n```\n\n### 對舊的瀏覽器 Hack\n\nMozilla 建議：\n> 所以，如果你想要在跨瀏覽器的環境模擬一個有排序的關聯陣列，你要麼強制使用兩個分離的陣列（其中一個給 keys，另一個給 values），或者建立一個單一屬性的物件陣列，等等。\n\n```js\n// 使用兩個分離的陣列\nvar objectKeys = [z, @, b, 1, 5];\nfor (item in objectKeys) {\n\tmyObject[item]\n...\n\n// 建立一個單一屬性的物件陣列\nvar myData = [{z: 1}, {'@': 2}, {b: 3}, {1: 4}, {5: 5}];\n```\n"},"2016-01-13-tip-to-measure-performance-of-a-javascript-block.md":{"name":"2016-01-13-tip-to-measure-performance-of-a-javascript-block.md","sha":"03f74efab5380bf90c644dda33c1254400acaa44","content":"---\nlayout: post\n\ntitle: 測量 JavaScript 程式碼區塊性能的 tip\ntip-number: 13\ntip-username: manmadareddy\ntip-username-profile: https://twitter.com/manmadareddy\ntip-tldr: 如果要快速的測量 JavaScript 程式碼區塊性能的話，我們可以使用 console 函式像是 `console.time(label)` 和 `console.timeEnd(label)`。\n\ncategories:\n    - zh_TW\n---\n\n如果要快速的測量 JavaScript 程式碼區塊性能的話，我們可以使用 console 函式像是 [`console.time(label)`](https://developer.chrome.com/devtools/docs/console-api#consoletimelabel) 和 [`console.timeEnd(label)`](https://developer.chrome.com/devtools/docs/console-api#consoletimeendlabel)。\n\n```javascript\nconsole.time(\"Array initialize\");\nvar arr = new Array(100),\n    len = arr.length,\n    i;\n\nfor (i = 0; i < len; i++) {\n    arr[i] = new Object();\n};\nconsole.timeEnd(\"Array initialize\"); // 輸出：陣列初始化：0.711ms\n```\n\n更多資訊：\n[Console object](https://github.com/DeveloperToolsWG/console-object)、\n[Javascript benchmarking](https://mathiasbynens.be/notes/javascript-benchmarking)。\n\n範例：[jsfiddle](https://jsfiddle.net/meottb62/) - [codepen](http://codepen.io/anon/pen/JGJPoa)（在瀏覽器 console 下輸出）。\n"},"2016-02-06-deduplicate-an-array.md":{"name":"2016-02-06-deduplicate-an-array.md","sha":"b13ab919a62e8f2a5ba1814fb2138cc74e2a5915","content":"---\nlayout: post\n\ntitle: 移除陣列重複元素\ntip-number: 37\ntip-username: danillouz\ntip-username-profile: https://www.twitter.com/danillouz\ntip-tldr: 如何從陣列中移除不同資料類型重複的元素。\n\n\ncategories:\n    - zh_TW\n---\n\n# 原始函數\n如果陣列只有包含原始數值，我們可以透過 [`filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter) 和 [`indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf) 方法來刪除重複的元素。\n\n```javascript\nvar deduped = [ 1, 1, 'a', 'a' ].filter(function (el, i, arr) {\n\treturn arr.indexOf(el) === i;\n});\n\nconsole.log(deduped); // [ 1, 'a' ]\n```\n\n## ES2015\n我們可以使用[箭頭函式](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions)來撰寫讓程式更簡潔。\n\n```javascript\nvar deduped = [ 1, 1, 'a', 'a' ].filter( (el, i, arr) => arr.indexOf(el) === i);\n\nconsole.log(deduped); // [ 1, 'a' ]\n```\n\n但是根據 [Sets](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set) 和 [`from`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from) 方法，我們可以用更簡潔的方式得到同樣的結果。\n\n```javascript\nvar deduped = Array.from( new Set([ 1, 1, 'a', 'a' ]) );\n\nconsole.log(deduped); // [ 1, 'a' ]\n```\n\n# 物件\n當元素都是物件時，我們不能使用相同的方法，因為物件儲存的值是參考原始儲存的值。\n\n```javascript\n1 === 1 // true\n\n'a' === 'a' // true\n\n{ a: 1 } === { a: 1 } // false\n```\n\n因此，我們需要改變我們的方式以及使用雜湊表。\n\n```javascript\nfunction dedup(arr) {\n\tvar hashTable = {};\n\n\treturn arr.filter(function (el) {\n\t\tvar key = JSON.stringify(el);\n\t\tvar match = Boolean(hashTable[key]);\n\n\t\treturn (match ? false : hashTable[key] = true);\n\t});\n}\n\nvar deduped = dedup([\n\t{ a: 1 },\n\t{ a: 1 },\n\t[ 1, 2 ],\n\t[ 1, 2 ]\n]);\n\nconsole.log(deduped); // [ {a: 1}, [1, 2] ]\n```\n\n因為在 JavaScript 雜湊表只是一個 `Object`，它的 key 的類型是 `String`。意思說，在同一個數值下，我們不能區分字串和數字，例如：`1` 和 `'1'`。\n\n```javascript\nvar hashTable = {};\n\nhashTable[1] = true;\nhashTable['1'] = true;\n\nconsole.log(hashTable); // { '1': true }\n```\n\n然而，因為我們使用了 [`JSON.stringify`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify), keys 是 `String` 的類型，會被轉成字串儲存，這樣 `hashTable` key 就是唯一的。\n\n```javascript\nvar hashTable = {};\n\nhashTable[JSON.stringify(1)] = true;\nhashTable[JSON.stringify('1')] = true;\n\nconsole.log(hashTable); // { '1': true, '\\'1\\'': true }\n```\n\n意思說重複相同的元素數值，但為不同類型的，可以被保留，而重複的元素仍然會被刪除。\n\n```javascript\nvar deduped = dedup([\n\t{ a: 1 },\n\t{ a: 1 },\n\t[ 1, 2 ],\n\t[ 1, 2 ],\n\t1,\n\t1,\n\t'1',\n\t'1'\n]);\n\nconsole.log(deduped); // [ {a: 1}, [1, 2], 1, '1' ]\n```\n\n# 資源\n## 方法\n* [`filter`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)\n* [`indexOf`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf)\n* [`from`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/from)\n* [`JSON.stringify`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)\n\n## ES2015\n* [箭頭函式](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions)\n* [Sets](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)\n\n## Stack overflow\n* [將陣列重複的元素移除](http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array/9229821#9229821)\n"},"2016-01-29-speed-up-recursive-functions-with-memoization.md":{"name":"2016-01-29-speed-up-recursive-functions-with-memoization.md","sha":"b24c8477994b68282184683550777c4a81b7d9dc","content":"---\nlayout: post\n\ntitle: 使用 memoization 加速遞迴\ntip-number: 29\ntip-username: hingsir\ntip-username-profile: https://github.com/hingsir\ntip-tldr: 大家對費式（Fibonacci）數列都很熟悉。我們可以在 20 秒內寫出以下的函式。它可以執行，但是效率不高。它做了大量的重複計算，我們可以快取先前的計算結果來加快計算速度。\n\n\ncategories:\n    - zh_TW\n---\n\n大家對費式（Fibonacci）數列都很熟悉。我們可以在 20 秒內寫出以下的函式。\n\n```js\nvar fibonacci = function(n){\n    return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);\n}\n```\n它可以執行，但是效率不高。它做了大量的重複計算，我們可以快取先前的計算結果來加快計算速度。\n\n```js\nvar fibonacci = (function() {\n  var cache = [0, 1]; // cache the value at the n index\n  return function(n) {\n    if (cache[n] === undefined) {\n      for (var i = cache.length; i <= n; ++i) {\n        cache[i] = cache[i-1] + cache[i-2];\n      }\n    }\n    return cache[n];\n  }\n})()\n```\n也許，我們可以定義高階函式，來接受一個函式作為參數，並回傳一個函式回傳的暫存值。\n\n```js\nvar memoize = function(func){\n    var cache = {};\n    return function(){\n        var key = Array.prototype.slice.call(arguments).toString();\n        return key in cache ? cache[key] : (cache[key] = func.apply(this, arguments));\n    }\n}\nfibonacci = memoize(fibonacci);\n```\n這裡是 ES6 版本的 memoize 函式。\n\n```js\nvar memoize = function(func){\n    const cache = {};\n    return (...args) => {\n        const key = [...args].toString();\n        return key in cache ? cache[key] : (cache[key] = func(...args));\n    }\n}\nfibonacci = memoize(fibonacci);\n```\n我們可以將 `memoize()` 使用在其他地方\n* GCD（最大公因數）\n\n```js\nvar gcd = memoize(function(a, b){\n    var t;\n    if (a < b) t = b, b = a, a = t;\n    while(b != 0) t = b, b = a % b, a = t;\n    return a;\n})\ngcd(27, 183); //=> 3\n```\n* 階乘計算\n\n```js\nvar factorial = memoize(function(n) {\n    return (n <= 1) ? 1 : n * factorial(n - 1);\n})\nfactorial(5); //=> 120\n```\n"}}