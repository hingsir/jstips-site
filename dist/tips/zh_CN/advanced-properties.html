<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><title>jstips - A JS tip per day</title><meta name="keywords" content="jstips,tips,js,javascript,front end"><meta name="description" content="Introduces these short and useful daily JavaScript tips that will allow you to improve your code writing. With less than 2 minutes each day, you will be able to read about performance, conventions, hacks, interview questions and all the items that the future of this awesome language holds for us"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scale=no"><link rel="icon" type="image/x-icon" href="../../images/favicon.ico"><link rel="stylesheet" type="text/css" href="../../css/all-7e45beae0a.min.css"><script type="text/javascript">window.onload = function(){
                document.getElementById('J_languages_select').onchange = function(){
                var lang = this.value;
                window.location.href = window.location.href.replace(/tips\/(\w+)\//,function($,$1){
                    return $.replace($1,lang);
                })
            }
        }</script></head><body><div class="main-content clearfix"><div id="sider-wrap" class="catalog"><div class="catalog-header"><h1><a href="https://github.com/loverajoel/jstips">A JS tip per day</a></h1><select id="J_languages_select"><option value="en">English</option><option value="zh_CN" selected="selected">简体中文</option></select></div><ul><li><a href="reminders-about-reduce-function-usage" class="" title="48.内置函数Reduce的使用">48.内置函数Reduce的使用</a></li><li><a href="basics-declarations" class="" title="47.变量声明">47.变量声明</a></li><li><a href="detect-document-ready-in-pure-js" class="" title="46.纯JS监听document是否加载完成">46.纯JS监听document是否加载完成</a></li><li><a href="calculate-the-max-min-value-from-an-array" class="" title="45.计算数组中的最大值/最小值">45.计算数组中的最大值/最小值</a></li><li><a href="know-the-passing-mechanism" class="" title="44.了解传值机制">44.了解传值机制</a></li><li><a href="use-destructuring-in-function-parameters" class="" title="43.函数参数内使用解构">43.函数参数内使用解构</a></li><li><a href="preventing-unapply-attacks" class="" title="42.预防unapply攻击">42.预防unapply攻击</a></li><li><a href="array-average-and-median" class="" title="41.数组平均值与中值">41.数组平均值与中值</a></li><li><a href="using-json-stringify" class="" title="40.使用JSON.Stringify">40.使用JSON.Stringify</a></li><li><a href="advanced-properties" class="cur" title="39.Javascript高级特性">39.Javascript高级特性</a></li><li><a href="flattening-multidimensional-arrays-in-javascript" class="" title="38.Javascript多维数组扁平化">38.Javascript多维数组扁平化</a></li><li><a href="deduplicate-an-array" class="" title="37.数组去重">37.数组去重</a></li><li><a href="observe-dom-changes" class="" title="36.扩展插件中观察DOM的变化">36.扩展插件中观察DOM的变化</a></li><li><a href="assignment-shorthands" class="" title="35.赋值技巧">35.赋值技巧</a></li><li><a href="implementing-asynchronous-loops" class="" title="34.实现异步循环">34.实现异步循环</a></li><li><a href="create-range-0...n-easily-using-one-line" class="" title="33.仅用一行生成0...(N-1)的数列">33.仅用一行生成0...(N-1)的数列</a></li><li><a href="map-to-the-rescue-adding-order-to-object-properties" class="" title="32.Map()的营救；使对象属性有顺序">32.Map()的营救；使对象属性有顺序</a></li><li><a href="avoid-modifying-or-passing-arguments-into-other-functions—it-kills-optimization" class="" title="31.避免修改和传递`arguments`给其他方法 — 影响优化">31.避免修改和传递`arguments`给其他方法 — 影响优化</a></li><li><a href="converting-truthy-falsy-values-to-boolean" class="" title="30.将truthy/falsy转换为布尔值">30.将truthy/falsy转换为布尔值</a></li><li><a href="speed-up-recursive-functions-with-memoization" class="" title="29.运用存储加速递归 Speed up recursive functions with memoization">29.运用存储加速递归 Speed up recursive functions with memoization</a></li><li><a href="curry-vs-partial-application" class="" title="28.柯里化(currying)与部分应用(partial application)">28.柯里化(currying)与部分应用(partial application)</a></li><li><a href="short-circuit-evaluation-in-js" class="" title="27.JS中的短路求值">27.JS中的短路求值</a></li><li><a href="filtering-and-sorting-a-list-of-strings" class="" title="26.过滤并排序字符串列表">26.过滤并排序字符串列表</a></li><li><a href="Using-immediately-invoked-function-expression" class="" title="25.使用立即执行函数表达式">25.使用立即执行函数表达式</a></li><li><a href="use_===_instead_of_==" class="" title="24.使用 === 而不是 ==">24.使用 === 而不是 ==</a></li><li><a href="converting-to-number-fast-way" class="" title="23.转换为数字的更快方法">23.转换为数字的更快方法</a></li><li><a href="two-ways-to-empty-an-array" class="" title="22.清空数组的两种方法">22.清空数组的两种方法</a></li><li><a href="shuffle-an-array" class="" title="21.对数组洗牌">21.对数组洗牌</a></li><li><a href="return-objects-to-enable-chaining-of-functions" class="" title="20.返回对象，使方法可以链式调用">20.返回对象，使方法可以链式调用</a></li><li><a href="safe-string-concatenation" class="" title="19.安全的字符串拼接">19.安全的字符串拼接</a></li><li><a href="rounding-the-fast-way" class="" title="18.更快的取整">18.更快的取整</a></li><li><a href="nodejs-run-a-module-if-it-is-not-required" class="" title="17.Node.js - 运行未被引用的模块">17.Node.js - 运行未被引用的模块</a></li><li><a href="passing-arguments-to-callback-functions" class="" title="16.向回调方法传递参数">16.向回调方法传递参数</a></li><li><a href="even-simpler-way-of-using-indexof-as-a-contains-clause" class="" title="15.更简单的使用indexOf实现contains功能">15.更简单的使用indexOf实现contains功能</a></li><li><a href="fat-arrow-functions" class="" title="14.箭头函数">14.箭头函数</a></li><li><a href="tip-to-measure-performance-of-a-javascript-block" class="" title="13.测量javascript代码块性能的小知识">13.测量javascript代码块性能的小知识</a></li><li><a href="pseudomandatory-parameters-in-es6-functions" class="" title="12.ES6中的伪强制参数">12.ES6中的伪强制参数</a></li><li><a href="hoisting" class="" title="11.变量提升">11.变量提升</a></li><li><a href="check-if-a-property-is-in-a-object" class="" title="10.检查某对象是否有某属性">10.检查某对象是否有某属性</a></li><li><a href="template-strings" class="" title="09.模板字符串">09.模板字符串</a></li><li><a href="converting-a-node-list-to-an-array" class="" title="08.将Node List转换为数组(Array)">08.将Node List转换为数组(Array)</a></li><li><a href="use-strict-and-get-lazy" class="" title="07.使用&#34;use strict&#34; 变得懒惰">07.使用&#34;use strict&#34; 变得懒惰</a></li><li><a href="writing-a-single-method-for-arrays-and-a-single-element" class="" title="06.可以接受单参数与数组的方法">06.可以接受单参数与数组的方法</a></li><li><a href="differences-between-undefined-and-null" class="" title="05.undefined与null的区别">05.undefined与null的区别</a></li><li><a href="sorting-strings-with-accented-characters" class="" title="04.排列含音节字母的字符串">04.排列含音节字母的字符串</a></li><li><a href="improve-nested-conditionals" class="" title="03.优化嵌套的条件语句">03.优化嵌套的条件语句</a></li><li><a href="keys-in-children-components-are-important" class="" title="02.子容器的Key是很重要的">02.子容器的Key是很重要的</a></li><li><a href="angularjs-digest-vs-apply" class="" title="01.AngularJs - $digest vs $apply">01.AngularJs - $digest vs $apply</a></li><li><a href="insert-item-inside-an-array" class="" title="00.向数组中插入元素">00.向数组中插入元素</a></li></ul></div><div id="content-wrap"><div id="readme" class="boxed-group clearfix announce instapaper_body md"><article class="markdown-body entry-content" itemprop="mainContentOfPage"><h2 id="-39-javascript-">#39 - Javascript高级特性</h2><blockquote><p>2016-02-08 by <a href="https://github.com/mallowigi">@mallowigi</a></p></blockquote><p>在Javascript里配置对象属性是可以实现的，比如将一个参数设为伪私有或者只读。这个特性从ECMAScript 5.1开始就可以使用了，因此近来的浏览器都是支持的。 要实现这些功能，你需要使用<code>Object</code>的原型方法<code>defineProperty</code>，像这样：</p><pre><code class="lang-js"><span class="hljs-keyword">var</span> a = {};
Object.defineProperty(a, <span class="hljs-string">'readonly'</span>, {
  <span class="hljs-keyword">value</span>: <span class="hljs-number">15</span>,
  writable: <span class="hljs-keyword">false</span>
});

a.<span class="hljs-keyword">readonly</span> = <span class="hljs-number">20</span>;
console.log(a.<span class="hljs-keyword">readonly</span>); <span class="hljs-comment">// 15</span>
</code></pre><p>语法如下：</p><pre><code class="lang-js"><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.defineProperty</span>(<span class="hljs-selector-tag">dest</span>, <span class="hljs-selector-tag">propName</span>, <span class="hljs-selector-tag">options</span>)
</code></pre><p>或者定义多个：</p><pre><code class="lang-js"><span class="hljs-selector-tag">Object</span><span class="hljs-selector-class">.defineProperties</span>(dest, {
  <span class="hljs-attribute">propA</span>: optionsA,
  <span class="hljs-attribute">propB</span>: optionsB, <span class="hljs-comment">//...</span>
})
</code></pre><p><code>options</code>包含如下的属性：</p><ul><li><em>value</em>: 如果参数不是<code>getter</code>（请看下文），<code>value</code>是必须的。<code>{a: 12}</code> === <code>Object.defineProperty(obj, &#39;a&#39;, {value: 12})</code></li><li><em>writable</em>: 将参数设为只读。需要注意的是如果参数是嵌套对象，它的元素仍是能可修改的。</li><li><em>enumerable</em>: 将参数设为隐藏。这意味着<code>for ... of</code>循环和<code>stringify</code>的结果里不会包含这些参数，但是这个参数还是存在的。提示：这并不意味着参数是私有的！他依旧可以从外界访问，只是意味着不会被打印。</li><li><em>configurable</em>: 将属性设置为不能更改，比如：防止参数被删除或重新定义。如果此对象是一个嵌套对象，他的参数依旧是可配置的。</li></ul><p>所以如果想创建私有静态变量，你可以这样定义：</p><pre><code class="lang-js">Object.defineProperty(obj, <span class="hljs-string">'myPrivateProp'</span>, {<span class="hljs-string">value:</span> val, <span class="hljs-string">enumerable:</span> <span class="hljs-literal">false</span>, <span class="hljs-string">writable:</span> <span class="hljs-literal">false</span>, <span class="hljs-string">configurable:</span> <span class="hljs-literal">false</span>});
</code></pre><p>除了配置属性，由于<code>defineProperty</code>第二个参数是字符串，所以允许我们定义<em>动态变量(defineProperty)</em>。例如，我们可以说我们要根据一些外部配置创建一个属性：</p><pre><code class="lang-js">
<span class="hljs-variable"><span class="hljs-keyword">var</span> obj</span> = {
  getTypeFromExternal(): <span class="hljs-literal">true</span> <span class="hljs-comment">// illegal in ES5.1</span>
}

Object.defineProperty(obj, getTypeFromExternal(), {value: <span class="hljs-literal">true</span>}); <span class="hljs-comment">// ok</span>

<span class="hljs-comment">// For the example sake, ES6 introduced a new syntax:</span>
<span class="hljs-variable"><span class="hljs-keyword">var</span> obj</span> = {
  [getTypeFromExternal()]: <span class="hljs-literal">true</span>
}
</code></pre><p>还没有结束！高级特性允许我们创建<strong>getter</strong>和<strong>setter</strong>，就像其他面向对象(OOP)语言！这种情况下，我们不能使用<code>writable</code>、<code>enumerable</code>和<code>configurable</code>参数，而是：</p><pre><code class="lang-js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Foobar</span> <span class="hljs-params">()</span> </span>{
  <span class="hljs-keyword">var</span> _foo; <span class="hljs-comment">//  true private property</span>

  Object.defineProperty(obj, <span class="hljs-string">'foo'</span>, {
    <span class="hljs-keyword">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>{ <span class="hljs-keyword">return</span> _foo; }
    <span class="hljs-keyword">set</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(value)</span> </span>{ _foo = value }
  });

}

<span class="hljs-keyword">var</span> foobar = <span class="hljs-keyword">new</span> Foobar();
foobar.foo; <span class="hljs-comment">// 15</span>
foobar.foo = <span class="hljs-number">20</span>; <span class="hljs-comment">// _foo = 20</span>
</code></pre><p>除了封装与先进的访问器这些明显的优点，你还发现我们并没有“调用”<code>getter</code>，而是不需要使用小括号直接“取得”了属性！这太棒了！例如，我们可以想象我们有一个多层嵌套对象，像这样：</p><pre><code class="lang-js">var obj = {<span class="hljs-string">a:</span> {<span class="hljs-string">b:</span> {<span class="hljs-string">c:</span> [{<span class="hljs-string">d:</span> <span class="hljs-number">10</span>}, {<span class="hljs-string">d:</span> <span class="hljs-number">20</span>}] } } };
</code></pre><p>现在我们不需要调用<code>a.b.c[0].d</code>（其中某个属性可能是<code>undefined</code>且抛出错误），我们可以创建一个别名：</p><pre><code class="lang-js">Object.defineProperty(obj, 'firstD', {
  <span class="hljs-attribute">get</span>: function () { return a &amp;&amp; a<span class="hljs-variable">.b</span> &amp;&amp; a<span class="hljs-variable">.b</span><span class="hljs-variable">.c</span> &amp;&amp; a<span class="hljs-variable">.b</span><span class="hljs-variable">.c</span>[0] &amp;&amp; a<span class="hljs-variable">.b</span><span class="hljs-variable">.c</span>[0]<span class="hljs-variable">.d</span> }
})

console<span class="hljs-variable">.log</span>(obj<span class="hljs-variable">.firstD</span>) // 10
</code></pre><h3 id="-">提示</h3><p>如果你定义了<code>getter</code>而没有定义<code>setter</code>却仍要给它赋值，你将会得到一个错误。这在使用像<code>$.extend</code>或<code>_.merge</code>这样的辅助方法时是尤为重要的。要小心！</p><h3 id="-">链接</h3><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">defineProperty</a></li><li><a href="http://bdadam.com/blog/defining-properties-in-javascript.html">Defining properties in JavaScript</a></li></ul></article></div><a id="goto-catalog" href="catalog.html">&lt;&lt;返回目录</a><!-- 多说分享 start --><div class="ds-share flat" data-thread-key="jstips_39" data-title="Javascript高级特性" data-images="http://jstips.hingsir.com/dist/images/github.jpg" data-content="怎样给一个对象添加私有参数、`getter`或`setter`。" data-url="http://jstips.hingsir.com/dist/tips/zh_CN/advanced-properties.html"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li><a class="ds-more" href="javascript:void(0);">分享到：</a></li><li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li><li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li><li><a class="ds-qq" href="javascript:void(0);" data-service="qq">QQ</a></li></ul></div></div><!-- 多说分享 end --><!-- 多说评论框 start --><div class="ds-thread" data-thread-key="jstips_39" data-title="Javascript高级特性" data-url="http://jstips.hingsir.com/dist/tips/zh_CN/advanced-properties.html"></div><!-- 多说评论框 end --><!-- 多说公共JS代码 start (一个网页只需插入一次) --><script type="text/javascript">var duoshuoQuery = {short_name:"hingsir"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0]
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();</script><!-- 多说公共JS代码 end --><div class="site-footer"><p class="copyright">Powered by <a href="https://github.com/hingsir">@hingsir</a>, 2016</p></div></div></div><a id="forkme" href="https://github.com/hingsir/jstips-site"><img style="position: absolute; top: 0; right: 0; border: 0;z-index:100" src="https://camo.githubusercontent.com/a6677b08c955af8400f44c6298f40e7d19cc5b2d/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f677261795f3664366436642e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_gray_6d6d6d.png"></a><script>var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?d2663479c9de1b01cbc8485ab8cb623d";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();</script></body></html>