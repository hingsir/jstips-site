<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>A JS tip per day!</title>
    <link rel="stylesheet" type="text/css" href="../css/github_1.css">
    <link rel="stylesheet" type="text/css" href="../css/github_2.css">
</head>
</head>
<body>
    <ul>
        
            <li><a href="21.html">21.Shuffle an Array</a></li>
        
            <li><a href="20.html">20.Return objects to enable chaining of functions</a></li>
        
            <li><a href="19.html">19.Safe string concatenation</a></li>
        
            <li><a href="18.html">18.Rounding the fast way</a></li>
        
            <li><a href="17.html">17.Node.js: Run a module if it is not required</a></li>
        
            <li><a href="16.html">16.Passing arguments to callback functions</a></li>
        
            <li><a href="15.html">15.Even simpler way of using indexOf as a contains clause</a></li>
        
            <li><a href="14.html">14.Fat Arrow Functions #ES6</a></li>
        
            <li><a href="13.html">13.Tip to measure performance of a javascript block</a></li>
        
            <li><a href="12.html">12.Pseudomandatory parameters in ES6 functions #ES6</a></li>
        
            <li><a href="11.html">11.Hoisting</a></li>
        
            <li><a href="10.html">10.Check if a property is in a Object</a></li>
        
            <li><a href="09.html">09.Template Strings</a></li>
        
            <li><a href="08.html">08.Converting a Node List to an Array</a></li>
        
            <li><a href="07.html">07.&#34;use strict&#34; and get lazy</a></li>
        
            <li><a href="06.html">06.Writing a single method for arrays or single elements</a></li>
        
            <li><a href="05.html">05.Differences between `undefined` and `null`</a></li>
        
            <li><a href="04.html">04.Sorting strings with accented characters</a></li>
        
            <li><a href="03.html">03.Improve Nested Conditionals</a></li>
        
            <li><a href="02.html">02.ReactJs - Keys in children components are important</a></li>
        
            <li><a href="1.html">1.AngularJs: `$digest` vs `$apply`</a></li>
        
            <li><a href="0.html">0.Insert item inside an Array</a></li>
        
    </ul>
    <div id="content-wrap">
        &lt;h2&gt;#1 - AngularJs: &lt;code&gt;$digest&lt;/code&gt; vs &lt;code&gt;$apply&lt;/code&gt;&lt;/h2&gt;

&lt;blockquote&gt;&lt;p&gt;2016-01-01  by &lt;a href=&#34;https://twitter.com/loverajoel&#34;&gt;@loverajoel&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;One of the most appreciated features of AngularJs is the two way data binding. In order to make this work AngularJs evaluates the changes between the model and the view through cycles(&lt;code&gt;$digest&lt;/code&gt;). You need to understand this concept in order to understand how the framework works under the hood.&lt;/p&gt;

&lt;p&gt;Angular evaluates each watcher whenever one event is fired, this is the known &lt;code&gt;$digest&lt;/code&gt; cycle.
Sometimes you have to force to run a new cycle manually and you must choose the correct option because this phase is one of the most influential in terms of performance.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;$apply&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;This core method lets you to start the digestion cycle explicitly, that means that all watchers are checked, the entire application starts the &lt;code&gt;$digest loop&lt;/code&gt;. Internally after execute an optional function parameter, call internally to &lt;code&gt;$rootScope.$digest();&lt;/code&gt;.&lt;/p&gt;

&lt;h3&gt;&lt;code&gt;$digest&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;In this case the &lt;code&gt;$digest&lt;/code&gt; method starts the &lt;code&gt;$digest&lt;/code&gt; cycle for the current scope and its children. You should notice that the parents scopes will not be checked
 and not be affected.&lt;/p&gt;

&lt;h3&gt;Recommendations&lt;/h3&gt;

&lt;ul&gt;&lt;li&gt;Use &lt;code&gt;$apply&lt;/code&gt; or &lt;code&gt;$digest&lt;/code&gt; only when browser DOM events have triggered outside of AngularJS.&lt;/li&gt;&lt;li&gt;&lt;p&gt;Pass a function expression to &lt;code&gt;$apply&lt;/code&gt;, this have a error handling mechanism and allow integrate changes in the digest cycle&lt;/p&gt;&lt;p&gt;&lt;code&gt;javascript
$scope.$apply(() =&amp;gt; {
	$scope.tip = &amp;#39;Javascript Tip&amp;#39;;
});
&lt;/code&gt;&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;If only needs update the current scope or its children use &lt;code&gt;$digest&lt;/code&gt;, and prevent a new digest cycle for the whole application. The performance benefit it&amp;#39;s self evident&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;code&gt;$apply()&lt;/code&gt; is hard process for the machine and can lead to performance issues when having a lot of binding.&lt;/li&gt;&lt;li&gt;If you are using &amp;gt;AngularJS 1.2.X, use &lt;code&gt;$evalAsync&lt;/code&gt; is a core method that will evaluate the expression during the current cycle or the next. This can improve your application&amp;#39;s performance.&lt;/li&gt;&lt;/ul&gt;    </div>
</ul>
</body>
</html>